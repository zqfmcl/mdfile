---
title: Java题解IO
date: 2019-10-06 10:00:00
tags: 题解
 
---

## 第十八章 IO

public class DirList1a {         

​       public static void main(final String[] args) {

​              File path = new File(".");

​              final String[] list;

​              if(args.length < 2) { 

​                     list = path.list();

​                     System.out.println("Usage: enter filtering regex");

​                     System.out.println(

​                     "followed by words, one or more of which each file must contain.");

​              }

​              else {

​                     list = path.list(new FilenameFilter() {

​                            private Pattern pattern = Pattern.compile(args[0]);

​                            public boolean accept(File dir, String name) {

​                                   return pattern.matcher(name).matches() &&

​                                   !(Collections.disjoint(

​                                          Arrays.asList(args).subList(1, args.length),

​                                          new TextFile(name, "\\W+")

​                                   ));

​                            }

​                     });

​              }

​              Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);

​              for(String dirItem : list)

​                     System.out.println(dirItem);

​       }

}

 

public class DirList1b {         

​       public static void main(final String[] args) {

​              File path = new File(".");

​              final String[] list;

​              if(args.length == 0) { 

​                     list = path.list();

​                     System.out.println(

​                            "Usage: enter words, one or more of which each file must contain");

​              }

​              else {

​                     list = path.list(new FilenameFilter() {

​                            public boolean accept(File dir, String name) {

​                                   return !(Collections.disjoint(

​                                                 Arrays.asList(args),

​                                                 new TextFile(name, "\\W+")

​                                          )

​                                   );

​                            }

​                     });

​              }

​              Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);

​              for(String dirItem : list)

​                     System.out.println(dirItem);

​       }

}

 

public class SortedDirList2 {

​       private String[] dirList;

​       public SortedDirList2(File dir) {

​              dirList = dir.list();

​              Arrays.sort(dirList, String.CASE_INSENSITIVE_ORDER);

​       }

​       public String[] list() { return dirList; }

​       public String[] list(String regex) {

​              Pattern pattern = Pattern.compile(regex);

​              ArrayList<String> slist = new ArrayList<String>();

​              int count = 0;

​              for(String s : dirList) {

​                     if(pattern.matcher(s).matches()) {

​                            count++;

​                            slist.add(s);

​                     }

​              }

​              return slist.toArray(new String[count]);

​       }

​       public String toString() {

​              StringBuilder sb = new StringBuilder();

​              for(String s : dirList) sb.append(s + '\n');

​              return sb.toString();

​       }

​       public static void main(String[] args) {

​              SortedDirList2 dirList = new SortedDirList2(new File("."));

​              System.out.println(dirList);

​              for(String s : dirList.list()) 

​                     System.out.println(s);

​              System.out.println();

​              for(String s : dirList.list(".+\\.java"))

​                     System.out.println(s);

​       }

}

 

public class DirListFileSizes { 

​       public static void main(final String[] args) {

​              File path = new File(".");

​              File[] files;

​              if(args.length == 0)

​                    files = path.listFiles(); 

​              else

​                     files = path.listFiles(new FileFilter() {

​                            private Pattern pattern = Pattern.compile(args[0]);

​                            public boolean accept(File file) {

​                                   return pattern.matcher(file.getPath()).matches();

​                            }

​                     });

​              Arrays.sort(files);

​              long sum = 0;

​              for(File f : files) {

​                     System.out.print(f + ": ");

​                     System.out.println(f.length());

​                     sum += f.length();

​              }

​              System.out.println("Total size: " + sum);

​       }

}

 

public class Ex4 {

​       public static void main(String[] args) {

​              long sum = 0;

​              if(args.length == 0) {

​                     for(File file : Directory.walk(".").files) {

​                            System.out.print(file + ": ");

​                            System.out.println(file.length());

​                            sum += file.length();

​                     }

​                     

​              }

​              else 

​                     for(String arg : args) {

​                            {

​                            for(File file : Directory.walk(".", arg).files) {

​                                   System.out.print(file + ": ");

​                                   System.out.println(file.length());

​                                   sum += file.length();

​                            }

​                            System.out.println();

​                     }

​              }

​              System.out.println("Total size: " + sum);

​       }

}

 

public class ProcessFiles5 {

​       public interface Strategy {

​                  void process(File file);

​      }

​      private Strategy strategy;

​      private String regex;

​       public ProcessFiles5(Strategy strategy, String regex) {

​                  this.strategy = strategy;

​           this.regex = regex;

​      }

​      public void start(String[] args) {

​                  try {

​                        if(args.length == 0)

​                      processDirectoryTree(new File("."));

​                 else

​                      for(String arg : args) {

​                            File fileArg = new File(arg);

​                            if(fileArg.isDirectory())

​                                        processDirectoryTree(fileArg);

​                            else {

​                                   Pattern pattern = Pattern.compile(regex);

​                                   if(pattern.matcher(arg).matches())                                                    strategy.process(

​                                                     new File(arg).getCanonicalFile());

​                            }

​                      }

​                  } catch(IOException e) {

​                        throw new RuntimeException(e);

​                  }

​      }

​      public void processDirectoryTree(File root) throws IOException {

​                  for(File file : Directory.walk(

​                      root.getAbsolutePath(), regex))

​                 strategy.process(file.getCanonicalFile());

​      }

​           public static void main(String[] args) {

​                  new ProcessFiles5(new ProcessFiles5.Strategy() {

​                        public void process(File file) {

​                             System.out.println(file);

​                        }

​                  }, ".*D.*").start(args);

​      }

} 

public class ModifiedAfter6 {

​       public static void main(final String[] args) {

​              if(args.length != 2) {

​                     System.out.println("Usage: directory date(mm                      System.out.println("(Outputs a listing of all java files in the given directory" +

​                            "\nthat were last modified on or after the given date.)");

​                     return;

​              }

​              final SimpleDateFormat sdf = new SimpleDateFormat("MM        new ProcessFiles(new ProcessFiles.Strategy() {

​                     public void process(File file) {

​                            Date modDate = new Date(file.lastModified());

​                            try {

​                                   if(modDate.after(sdf.parse(args[1])))

​                                          System.out.println(file);

​                            } catch(ParseException e) {

​                                   System.out.println(e.getMessage());

​                            }

​                     }

​              }, "java").start(args);

​       }

}

 

public class ReverseLines7 {

​             public static String readAndReverse(String filename) throws IOException {

​                           BufferedReader in = new BufferedReader(new FileReader(filename));

​              String s;

​              LinkedList<String> list = new LinkedList<String>(); 

​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null)

​                     list.add(s);            while(list.peekLast() != null)                     sb.append(list.pollLast() + "\n");               in.close();

​              return sb.toString();             

​       }

​       public static void main(String[] args) throws IOException {

​              System.out.print(readAndReverse("ReverseLines7.java"));

​       }

}

 

public class ReverseLines8 {

​             public static String readAndReverse(String filename) throws IOException {

​                           BufferedReader in = new BufferedReader(new FileReader(filename));

​              String s;

​              LinkedList<String> list = new LinkedList<String>(); 

​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null)

​                     list.add(s);            while(list.peekLast() != null)                     sb.append(list.pollLast() + "\n");               in.close();

​              return sb.toString();             

​       }

​       public static void main(String[] args) throws IOException {

​              if(args.length != 1) {

​                     System.out.println("Usage: enter file name");

​                     System.exit(1);

​              }

​              System.out.print(readAndReverse(args[0]));

​       }

}

 

public class ReverseLines9 {

​             public static String readAndReverse(String filename) throws IOException {

​                           BufferedReader in = new BufferedReader(new FileReader(filename));

​              String s;

​              LinkedList<String> list = new LinkedList<String>(); 

​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null)

​                     list.add(s.toUpperCase());          while(list.peekLast() != null)                     sb.append(list.pollLast() + "\n");            in.close();

​              return sb.toString();             

​       }

​       public static void main(String[] args) throws IOException {

​              if(args.length != 1) {

​                     System.out.println("Usage: enter file name");

​                     System.exit(1);

​              }

​              System.out.print(readAndReverse(args[0]));

​       }

}

 

public class ReverseLinesWordSearch10 {

​             public static String readReverseFind(String[] sa) throws IOException {

​                           BufferedReader in = new BufferedReader(new FileReader(sa[0]));

​              String s;

​              List<String> find = new ArrayList<String>();

​              for(String t : sa) find.add(t);

​              find.remove(0);           LinkedList<String> list = new LinkedList<String>(); 

​              StringBuilder sb = new StringBuilder();           while((s = in.readLine()) != null) {

​                                         List<String> line = Arrays.asList(s.split("\\W+"));

​                                         if(!(Collections.disjoint(line, find))) 

​                            list.add(s);            }

​              while(list.peekLast() != null)                     sb.append(list.pollLast() + "\n");               in.close();

​              return sb.toString();             

​       }

​       public static void main(String[] args) throws IOException {

​              if(args.length < 2) {

​                     System.out.println("Usage: enter file name\n" +

​                            "followed by words to find in lines of that file");

​                     System.exit(1);

​              }

​              System.out.print(readReverseFind(args));

​       }

}

public class GreenhouseController11 {

​             public static Map<String,Long> readEvents(String filename) 

​       throws IOException {

​              BufferedReader in = new BufferedReader(new FileReader(filename));

​              String s;

​              Map<String,Long> map = new HashMap<String,Long>();

​              while((s = in.readLine()) != null) {

​                     String [] sa = s.split("[()]");

​                     map.put(sa[0], new Long(sa[1]));

​              }

​              in.close();

​              return map;

​       }

​             private static Event makeEvent(GreenhouseControls gc, Map.Entry<String,Long> me) {

​              String key = me.getKey();

​              Long value = me.getValue();

​              if(key.equals("Bell")) return gc.new Bell(value);

​              if(key.equals("LightOn")) return gc.new LightOn(value);

​              if(key.equals("LightOff")) return gc.new LightOff(value);

​              if(key.equals("WaterOn")) return gc.new WaterOn(value);

​              if(key.equals("WaterOff")) return gc.new WaterOff(value);

​              if(key.equals("ThermostatDay")) return gc.new ThermostatDay(value);

​              if(key.equals("ThermostatNight")) return gc.new ThermostatNight(value);

​              return null;

​       }

​       public static void main(String[] args) {

​              GreenhouseControls gc = new GreenhouseControls();

​                                        try {

​                                         Map<String,Long> map = readEvents("Events.txt");

​                     Event[] eventList = new Event[map.size()];

​                     int i = 0;

​                                         for(Map.Entry<String,Long> me : map.entrySet()) {

​                            eventList[i++] = makeEvent(gc, me);

​                     }

​                     gc.addEvent(gc.new Restart(2000, eventList));

​                     if(args.length != 1) {

​                            System.out.println("Usage: enter integer terminate time");

​                            System.exit(0);

​                     }

​                     if(args.length == 1)

​                            gc.addEvent(new GreenhouseControls.Terminate(

​                                   new Integer(args[0])));

​              gc.run();

​              } catch(IOException e) {

​                     System.out.println(e);

​              }      

​       }      

}

 

interface EventFactory {

​       Event getEvent(GreenhouseControls gc, Long time);

}

 

class BellFactory implements EventFactory {

​       public Event getEvent(GreenhouseControls gc, Long time) {

​              return gc.new Bell(time);

​       }

}

 

class LightOnFactory implements EventFactory {

​       public Event getEvent(GreenhouseControls gc, Long time) {

​              return gc.new LightOn(time);

​       }

}

 

class LightOffFactory implements EventFactory {

​       public Event getEvent(GreenhouseControls gc, Long time) {

​              return gc.new LightOff(time);

​       }

}

 

class WaterOnFactory implements EventFactory {

​       public Event getEvent(GreenhouseControls gc, Long time) {

​              return gc.new WaterOn(time);

​       }

}

 

class WaterOffFactory implements EventFactory {

​       public Event getEvent(GreenhouseControls gc, Long time) {

​              return gc.new WaterOff(time);

​       }

}

 

class ThermostatDayFactory implements EventFactory {

​       public Event getEvent(GreenhouseControls gc, Long time) {

​              return gc.new ThermostatDay(time);

​       }

}

 

class ThermostatNightFactory implements EventFactory {

​       public Event getEvent(GreenhouseControls gc, Long time) {

​              return gc.new ThermostatNight(time);

​       }

}

 

public class GreenhouseController11b {

​             public static Map<String,Long> readEvents(String filename) 

​       throws IOException {

​              BufferedReader in = new BufferedReader(new FileReader(filename));

​              String s;

​              Map<String,Long> map = new HashMap<String,Long>();

​              while((s = in.readLine()) != null) {

​                     String [] sa = s.split("[()]");

​                     map.put(sa[0], new Long(sa[1]));

​              }

​              in.close();

​              return map;

​       }

​             private static Event makeEvent(GreenhouseControls gc, Map.Entry<String,Long> me) {

​              String key = me.getKey();

​              Long value = me.getValue();

​              if(key.equals("Bell")) return new BellFactory().getEvent(gc,value);

​              if(key.equals("LightOn")) return new LightOnFactory().getEvent(gc, value);

​              if(key.equals("LightOff")) return new LightOffFactory().getEvent(gc, value);

​              if(key.equals("WaterOn")) return new WaterOnFactory().getEvent(gc, value);

​              if(key.equals("WaterOff")) return new WaterOffFactory().getEvent(gc, value);

​              if(key.equals("ThermostatDay")) 

​                     return new ThermostatDayFactory().getEvent(gc, value);

​              if(key.equals("ThermostatNight")) 

​                     return new ThermostatNightFactory().getEvent(gc, value);

​              return null;

​       }

​       public static void main(String[] args) {

​              GreenhouseControls gc = new GreenhouseControls();

​                                        try {

​                                         Map<String,Long> map = readEvents("Events.txt");

​                     Event[] eventList = new Event[map.size()];

​                     int i = 0;

​                                         for(Map.Entry<String,Long> me : map.entrySet()) {

​                            eventList[i++] = makeEvent(gc, me);

​                     }

​                     gc.addEvent(gc.new Restart(2000, eventList));

​                     if(args.length != 1) {

​                            System.out.println("Usage: enter integer terminate time");

​                            System.exit(0);

​                     }

​                     if(args.length == 1)

​                            gc.addEvent(new GreenhouseControls.Terminate(

​                                   new Integer(args[0])));

​              gc.run();

​              } catch(IOException e) {

​                     System.out.println(e);

​              }      

​       }      

}

 

public class ReverseLines12 {

​             public static String readAndReverse(String filename) throws IOException {

​                           BufferedReader in = new BufferedReader(new FileReader(filename));

​              String s;

​              LinkedList<String> list = new LinkedList<String>(); 

​              StringBuilder sb = new StringBuilder();           String[] temp = filename.split("\\.");

​              String file = temp[0] + "Reversed." + temp[1]; 

​              PrintWriter out = new PrintWriter(file);            int lineCount = 1;

​              while((s = in.readLine()) != null)

​                                         list.add(lineCount++ + " " + s); 

​              while(list.peekLast() != null) {                   String t = list.pollLast();                    out.println(t);

​                     sb.append(t + "\n"); 

​              }

​              in.close();

​              out.close();          return sb.toString();             

​       }

​       public static void main(String[] args) throws IOException {

​              if(args.length != 1) {

​                     System.out.println("Usage: enter file name");

​                     System.exit(1);

​              }

​              System.out.println(readAndReverse(args[0]));

​       }

}

public class BasicFileOutput13 {

​       static String file = "BasicFileOutput13.out";

​       public static void main(String[] args) throws IOException {

​              LineNumberReader in = new LineNumberReader(

​                     new FileReader("BasicFileOutput13.java"));

​              PrintWriter out = new PrintWriter(file);

​              String s;

​              while((s = in.readLine()) != null )

​                     out.println(in.getLineNumber() + ": " + s);

​              out.close();

​                           System.out.println(BufferedInputFile.read(file));

​       }             

}

public class BasicFileOutput14 {

​       static String file = "BasicFileOutput14.out";

​       static String file2 = "BasicFileOutput142.out";

​       public static void main(String[] args) throws IOException {

​              BufferedReader in = new BufferedReader(

​                     new StringReader(

​                            BufferedInputFile.read("BasicFileOutput14.java")));

​                           PrintWriter out = new PrintWriter(

​                     new BufferedWriter(new FileWriter(file)));

​              int lineCount = 1;

​              String s;

​              long start = System.nanoTime();

​              while((s = in.readLine()) != null )

​                     out.println(lineCount++ + ": " + s);

​              long duration = System.nanoTime() - start;

​              out.close();

​              System.out.println("Buffered write:   " + duration + " nanoseconds");

​              BufferedReader in2 = new BufferedReader(

​                     new StringReader(

​                            BufferedInputFile.read("BasicFileOutput14.java")));

​                           PrintWriter out2 = new PrintWriter(new FileWriter(file2));

​              int lineCount2 = 1;

​              String s2;

​              long start2 = System.nanoTime();

​              while((s2 = in2.readLine()) != null )

​                     out2.println(lineCount2++ + ": " + s2);

​              long duration2 = System.nanoTime() - start2;

​              out2.close();

​              System.out.println("Unbuffered write: " + duration2 + " nanoseconds");

​                           System.out.println("file: " + BufferedInputFile.read(file));

​              System.out.println("file2: " + BufferedInputFile.read(file2));

​       }             

}

public class StoringAndRecoveringData15 {

​       public static void main(String[] args) throws IOException {

​              DataOutputStream out = new DataOutputStream(

​                     new BufferedOutputStream(

​                            new FileOutputStream("Data.txt")));

​              println("Initial out.size() = " + out.size());

​              byte[] ba = {0,1,2,3};

​                           out.write(ba,0,3);

​                           out.write(ba);

​              out.write((int)255);             out.writeBoolean(true);

​              out.writeByte((int)1000000);

​              out.writeBytes((String)"hi");

​              out.writeChar(120);

​              out.writeChars("hi");            

​              out.writeDouble(3.14159);

​              out.writeFloat(2.1f);

​              out.writeInt(1057);

​              out.writeLong(123456789L);

​              out.writeShort(123);

​              out.writeUTF("Nice piece of work");

​              println("After writing, out.size() = " + out.size());              

​              out.close();

​              println("Reading:");

​              DataInputStream in = new DataInputStream(

​                     new BufferedInputStream(

​                            new FileInputStream("Data.txt")));

​              byte[] baIn = new byte[3];

​              println("bytes read by in.read(baIn, 0, 3) = " + in.read(baIn, 0, 3));

​              print("baIn = ");

​              for(int i = 0; i < baIn.length; i++)

​                     print(baIn[i] + " ");

​              println();

​                           println("in.readInt() = " + in.readInt());

​              println("in.read() = " + in.read());        

​              println("in.readBoolean() = " + in.readBoolean());            

​              println("in.readByte() = " + in.readByte());         

​              println("in.read() = " + in.read());             println("in.read() = " + in.read());             println("in.readChar() = " + in.readChar());

​              println("in.readChar() = " + in.readChar());

​              println("in.readChar() = " + in.readChar());

​              println("in.readDouble() = " + in.readDouble());

​              println("in.readFloat() = " + in.readFloat());

​              println("in.readInt() = " + in.readInt());

​              println("in.readLong() = " + in.readLong());

​              println("in.readShort() = " + in.readShort());

​              println("in.readUTF() = " + in.readUTF());          

​       }

}

 

public class UsingRandomAccessFile16 {

​       static String file = "r16test.dat";

​       static void display() throws IOException {

​              RandomAccessFile rf = new RandomAccessFile(file, "r");

​              byte[] bIn = new byte[3];

​              rf.read(bIn);

​              for(int i = 0; i < bIn.length; i++)

​                     print(bIn[i] + " ");

​              println();

​                           println("rf.readInt() = " + rf.readInt());

​              println("rf.read() = " + rf.read());         

​              println("rf.readBoolean() = " + rf.readBoolean());             

​              println("rf.readByte() = " + rf.readByte());          

​              println("rf.read() = " + rf.read());              println("rf.read() = " + rf.read());              println("rf.readChar() = " + rf.readChar());

​              println("rf.readChar() = " + rf.readChar());

​              println("rf.readChar() = " + rf.readChar());

​              println("rf.readDouble() = " + rf.readDouble());

​              println("rf.readFloat() = " + rf.readFloat());

​              println("rf.readInt() = " + rf.readInt());

​              println("rf.readLong() = " + rf.readLong());

​              println("rf.readShort() = " + rf.readShort());

​              println("rf.readUTF() = " + rf.readUTF());

​              rf.close();

​       }

​       public static void main(String[] args) throws IOException {     

​              RandomAccessFile rf = new RandomAccessFile(file, "rw");

​              byte[] ba = {0,1,2,3};

​                           rf.write(ba,0,3);

​                           rf.write(ba);

​              rf.write((int)255);                rf.writeBoolean(true);

​              rf.writeByte((int)1000000);

​              rf.writeBytes((String)"hi");

​              rf.writeChar(120);

​              rf.writeChars("hi");        

​              rf.writeDouble(3.14159);

​              rf.writeFloat(2.1f);

​              rf.writeInt(1057);

​              rf.writeLong(123456789L);

​              rf.writeShort(123);

​              rf.writeUTF("Nice piece of work");              

​              display();        

​       }

}

 

public class CharCounter {

​       

​       public static void main(String[] args) {

​                           String fileName = "CharCounter.java";

​                           char[] ca = read(fileName).toCharArray();

​                           Set<Character> charSet = new TreeSet<Character>();    

​              for(char c : ca) charSet.add(c);                       List<Character> charList = new ArrayList<Character>();

​              for(char c : ca) charList.add(c);

​              Map<Character,Integer> charMap = new HashMap<Character,Integer>();

​              for(Character c : charSet) {

​                     int count = 0;

​                     for(Character d : charList) {

​                            if(d.equals(c)) count++;

​                     }

​                     charMap.put(c, count);

​              }  

​              print();

​              print(charMap);            

​       }

}

 

public class TextFile18 extends ArrayList<String> {

​            public static String read(String fileName) throws IOException {

​                  StringBuilder sb = new StringBuilder();

​                  BufferedReader in = new BufferedReader(new FileReader(

​                      new File(fileName).getAbsoluteFile()));

​                 try {

​                      String s;

​                      while((s = in.readLine()) != null) {

​                            sb.append(s);

​                            sb.append("\n");

​                      }

​                 } finally {

​                      in.close();

​                 }

​                  return sb.toString();

​      }

​           public static void write(String fileName, String text) throws IOException {

​                  PrintWriter out = new PrintWriter(

​                      new File(fileName).getAbsoluteFile());

​                 try {

​                      out.print(text);

​                 } finally {

​                      out.close();

​                 }

​           }

​           public TextFile18(String fileName, String splitter) throws IOException {

​                  super(Arrays.asList(read(fileName).split(splitter)));

​                                                    if(get(0).equals("")) remove(0);

​      }

​           public TextFile18(String fileName) throws IOException {

​                  this(fileName, "\n");

​      }

​      public void write(String fileName) throws IOException {

​                  PrintWriter out = new PrintWriter(

​                      new File(fileName).getAbsoluteFile());

​                 try {

​                      for(String item : this)

​                     out.println(item);

​                 } finally {

​                      out.close();

​                 }

​           }

​           public static void main(String[] args) {

​              try {

​                         String file = read("TextFile18.java");

​                         write("test.txt", file);

​                         TextFile18 text = new TextFile18("test.txt");

​                         text.write("test2.txt");

​                                                 TreeSet<String> words = new TreeSet<String>(

​                               new TextFile18("TextFile18.java", "\\W+"));               

​                                                 System.out.println(words.headSet("a"));

​              } catch(IOException e) {

​                     System.err.println("Caught " + e);

​                     e.printStackTrace();

​              }

​      }

} 

public class ByteCounter19 {       

​       public static void main(String[] args) {

​                           String fileName = "ByteCounter19.java";

​              try {

​                                         byte[] ba = read(fileName);         

​                                         Set<Byte> byteSet = new TreeSet<Byte>();      

​                     for(Byte b : ba) byteSet.add(b);                                           List<Byte> byteList = new ArrayList<Byte>();

​                     for(byte b : ba) byteList.add(b);

​                     Map<Byte,Integer> byteMap = new HashMap<Byte,Integer>();

​                     for(Byte b : byteSet) {

​                            int count = 0;

​                            for(Byte d : byteList) {

​                                   if(d.equals(b)) count++;

​                            }

​                     byteMap.put(b, count);

​                     }  

​                     print();

​                     print(byteMap);     

​              } catch(IOException e) {

​                     System.err.print("Caught " + e);

​              } 

​       }

}

 

public class Ex20 {

​       public static void main(String[] args) throws IOException {

​              for(File file : Directory.walk(".", ".*\\.class").files) {

​                     byte[] ba = read(file);

​                     for(int i = 0; i < 4; i++)

​                            print(Integer.toHexString(ba[i] & 0xff).toUpperCase());

​                     println();

​              }             

​       } 

}

 

public class Ex21 {

​       public static void main(String[] args) throws IOException {

​              File file = new File("Ex21.java");

​              BufferedInputStream inFile = 

​                     new BufferedInputStream(new

​                            FileInputStream(file));

​              System.setIn(inFile);             

​              BufferedReader stdin = new BufferedReader(

​                     new InputStreamReader(System.in));

​              String s;

​              while((s = stdin.readLine()) != null)

​                     System.out.println(s.toUpperCase());          

​       }

}

 

class OSExecute22Exception extends RuntimeException {

​       public OSExecute22Exception(String s) { super(s); }

}

 

class OSExecute22 {

​       public static List<String> command(String command) {

​              boolean err = false;

​              List<String> ls = new ArrayList<String>(); 

​              try {

​                     Process process = new ProcessBuilder(

​                            command.split(" ")).start();

​                     BufferedReader results = new BufferedReader(

​                            new InputStreamReader(process.getInputStream()));

​                     String s;                

​                     while((s = results.readLine()) != null) {

​                            ls.add(s);

​                     }

​                     BufferedReader errors = new BufferedReader(

​                            new InputStreamReader(process.getErrorStream()));

​                                                             while((s = errors.readLine()) != null) { 

​                            System.err.println(s);

​                            err = true;

​                     }

​              } catch(Exception e) {

​                                                             if(!command.startsWith("CMD                        command("CMD                       else

​                            throw new RuntimeException(e);

​              }

​              if(err)

​                     throw new OSExecute22Exception("Errors executing " + command);

​              return ls;

​       }

} 

 

public class OSExecute22Test {

​       public static void main(String[] args) {

​              for(String s : OSExecute22.command("javap OSExecute22Test"))

​                     println(s);

​       }

}

 

public class CharBufferPrinter23 {

​       public static boolean isPrintable(char c) {

​                           return (((c >= '!') && (c <= '~')) ? true : false);

​       }

​       public static void printCharBuffer(CharBuffer cb) {

​              cb.clear();            while(cb.hasRemaining()) {

​                     char c = cb.get();          

​                     if(isPrintable(c)) System.out.print(c);

​              }

​       } 

​       public static void main(String[] args) throws Exception {

​              char[] ca = {'w','x','y','z'};

​              CharBuffer cb = CharBuffer.wrap(ca);

​              print("CharBuffer by wrapping char[]: ");

​              printCharBuffer(cb);

​              println();

​              CharBuffer cb2 = CharBuffer.allocate(6);

​              char[] ca2 = {'s','t','u','v','w'};

​              cb2.put(ca2); 

​              print("CharBuffer by allocation: ");

​              printCharBuffer(cb2);

​              println();

​                           char[] ca3 = {(char)0x01, (char)0x07, (char)0x7F,'b','y','e'};

​              CharBuffer cb3 = CharBuffer.wrap(ca3);

​              print("CharBuffer including some unprintables: ");

​              printCharBuffer(cb3);           

​       }

}

 

public class DoubleBufferDemo24 {

​       private static final int BSIZE = 1024;

​       public static void main(String[] args) {

​              ByteBuffer bb = ByteBuffer.allocate(BSIZE);

​              DoubleBuffer db = bb.asDoubleBuffer();

​                           db.put(new 

​                     double[]{11.11,42.42,27.37,99.99,143.143,811.811,1016.1026});

​                           System.out.println(db.get(3));

​              db.put(3, 1811.1811);

​                           db.flip();

​              while(db.hasRemaining()) {

​                     double d = db.get();

​                     System.out.println(d);

​              }

​       }

}

public class AllocateDirectTest25 {     

​                   public static File toDirect(File f) throws IOException {

​              FileChannel fcIn = new FileInputStream(f).getChannel();  

​              ByteBuffer b = ByteBuffer.allocateDirect((int)f.length());

​              fcIn.read(b);

​              b.flip();

​              Charset cs = Charset.defaultCharset();       

​              CharBuffer cb = cs.decode(b);

​              String cbD1 = cb.toString().replace(

​                     ".allocate(", ".allocateDirect(");

​              String cbD = cbD1.replace(f.getName().split("\\.")[0], 

​                     f.getName().split("\\.")[0] + "Direct");

​              CharBuffer cbNew = CharBuffer.wrap(cbD);

​              String ext = (f.getName().split("\\."))[1];

​              String outFile = (f.getName().split("\\."))[0] + 

​                     "Direct." + ext;

​              FileChannel fcOut = 

​                     new FileOutputStream(

​                            new File(outFile)).getChannel();

​              fcOut.write(cs.encode(cbNew));          

​                           fcIn.close();

​              fcOut.close();

​              return new File(outFile);

​       }

​             public static void Tester(String s) {

​              try {                     Class c = Class.forName(s);

​                     String name = c.getSimpleName();

​                     print("Testing: " + name);

​                     @SuppressWarnings("unchecked")

​                     Method m = c.getMethod("main", String[].class);

​                                                             String[] sa = new String[]{"ChannelCopy.java", "Test.txt"};

​                     long startRun = System.nanoTime(); 

​                     m.invoke(c.newInstance(), (Object)sa);

​                     long duration = System.nanoTime() - startRun;

​                     print("\nTime to run " + name + " = " 

​                            + duration + " nanoseconds");                         

​              } catch(Exception e) {

​                     e.printStackTrace(System.err);

​              }

​       }

​       public static long allocationTime(int i) { 

​              long start = System.nanoTime();

​              ByteBuffer bb = ByteBuffer.allocate(i);

​              return System.nanoTime() - start;

​       }      

​       public static long directAllocationTime(int i) { 

​              long start = System.nanoTime();

​              ByteBuffer bb = ByteBuffer.allocateDirect(i);

​              return System.nanoTime() - start;

​       }

​       

​       public static void main(final String[] args) throws IOException {

​                           print("Time to allocate 1024 bytes = " 

​                     + allocationTime(1024) + " nanoseconds");

​              print("Time to allocateDirect 1024 bytes = " 

​                     + directAllocationTime(1024) + " nanoseconds");

​              print("Time to allocate 48 bytes = " 

​                     + allocationTime(48) + " nanoseconds");

​              print("Time to allocateDirect 48 bytes = " 

​                     + directAllocationTime(48) + " nanoseconds");

​              print("Time to allocate 1 byte = " 

​                     + allocationTime(1) + " nanoseconds");

​              print("Time to allocateDirect 1 byte = " 

​                     + directAllocationTime(1) + " nanoseconds");

​              Tester("GetChannel");

​              toDirect(new File("GetChannel.java"));

​                           Tester("GetChannelDirect");

​              Tester("BufferToText");

​              toDirect(new File("BufferToText.java"));

​                           Tester("BufferToTextDirect");

​              Tester("ChannelCopy");

​              toDirect(new File("ChannelCopy.java"));

​                           Tester("ChannelCopyDirect");

​              Tester("GetData");

​              toDirect(new File("GetData.java"));

​                           Tester("GetDataDirect");

​              Tester("IntBufferDemo");

​              toDirect(new File("IntBufferDemo.java"));

​                           Tester("IntBufferDemoDirect");

​              Tester("UsingBuffers");

​              toDirect(new File("UsingBuffers.java"));

​                           Tester("UsingBuffersDirect");

​       }

}

 

public class JGrep26  {

​       public static void main(String[] args) throws Exception {

​              if(args.length < 2) {

​                     System.out.println("Usage: java JGrep26 file regex");

​                     System.exit(0);

​              }

​              FileChannel fc = new FileInputStream(args[0]).getChannel();          

​              MappedByteBuffer in = 

​                     fc.map(FileChannel.MapMode.READ_ONLY, 0, 

​                            new File(args[0]).length());

​                           String[] sa = Charset.forName(System.getProperty("file.encoding"))

​                     .decode(in).toString().split("\n");

​              Pattern p = Pattern.compile(args[1]);         

​              Matcher m = p.matcher("");              int index = 0;

​              for(String line : sa) {

​                     m.reset(line);

​                     while(m.find())

​                            System.out.println(index++ + ": " + 

​                                   m.group() + ": " + m.start());

​              }

​              fc.close();

​       }

}

 

class A implements Serializable { 

​       private int i;    

​       A(int i) { this.i = i; }

​       public String toString() { return "A:" + i; }

} 

 

class B implements Serializable {

​       private char c;

​       private A a;

​       B(char c, A a) {

​              this.c = c;

​              this.a = a;

​       }

​       public String toString() {

​              return "B:" + c + " " + a;

​       }      

}

 

public class SerializationTest implements Serializable {

​       private static Random rand = new Random();

​       public static void main(String[] args) 

​       throws ClassNotFoundException, IOException {

​              B b = new B('x', new A(rand.nextInt(100)));

​              System.out.println("b: " + b);

​              ObjectOutputStream out = new ObjectOutputStream(

​                     new FileOutputStream("STest.out"));

​              out.writeObject(b);

​              out.close();

​              ObjectInputStream in = new ObjectInputStream(

​                     new FileInputStream("STest.out"));

​              B b2 = (B)in.readObject();

​              System.out.println("b2: " + b2);          

​       }

}

 

class Blip1 implements Externalizable {

​       public Blip1() {

​              print("Blip1 Constructor");

​       }

​       public void writeExternal(ObjectOutput out) 

​       throws  IOException {

​              print("Blip1.writeExternal");

​       }

​       public void readExternal(ObjectInput in) 

​       throws IOException, ClassNotFoundException {

​              print("Blip1.readExternal");

​       }

}

 

public class BlipCheck implements Externalizable {

​                                     public void writeExternal(ObjectOutput out) 

​       throws IOException {

​              print("BlipCheck writeExternal");

​       }

​       public void readExternal(ObjectInput in) 

​       throws IOException, ClassNotFoundException {

​              print("BlipCheck readExternal");

​       }

}

 

class Blips {

​       public static void main(String[] args) 

​       throws IOException, ClassNotFoundException {

​              print("Constructing objects:");

​              Blip1 b1 = new Blip1();

​              Blip2 b2 = new Blip2();

​              BlipCheck bc = new BlipCheck();

​              ObjectOutputStream o = new ObjectOutputStream(

​                     new FileOutputStream("Blips.out"));

​              print("Saving objects:");

​              o.writeObject(b1);

​              o.writeObject(b2);

​              o.writeObject(bc);

​              o.close();

​                           ObjectInputStream in = new ObjectInputStream(

​                     new FileInputStream("Blips.out"));

​              print("Recovering b1:");

​              b1 = (Blip1)in.readObject();

​              print("Recovering b2:");

​              b2 = (Blip2)in.readObject();

​              print("Recovering bc:");

​              bc = (BlipCheck)in.readObject();

​       }

}

 

public class Blip29 implements Externalizable {

​       private int i;

​       private String s;   public Blip29() {

​              print("Blip29 Contstructor");

​                    }

​       public Blip29(String x, int a) {

​              print("Blip29(String x, int a)");

​              s = x;

​              i = a;

​                    }

​       public String toString() { return s + i; }

​       public void writeExternal(ObjectOutput out) 

​       throws IOException {

​              print("Blip29.writeExternal");

​                                                                                     }

​       public void readExternal(ObjectInput in)

​       throws IOException, ClassNotFoundException {

​              print("Blip29.readExternal");

​                                                                                     }

​       public static void main(String[] args)

​       throws IOException, ClassNotFoundException {

​              print("Constructing objects:");

​              Blip29 b29 = new Blip29("A String ", 47);

​              print(b29);

​              ObjectOutputStream o = new ObjectOutputStream(

​                     new FileOutputStream("Blip29.out"));

​              print("Saving object:");

​              o.writeObject(b29);

​              o.close();

​                           ObjectInputStream in = new ObjectInputStream(

​                     new FileInputStream("Blip29.out"));

​              print("Recovering b29:");

​              b29 = (Blip29)in.readObject();

​              print(b29);

​       }

}

 

abstract class Shape implements Serializable {

​       public static final int RED = 1, BLUE = 2, GREEN = 3;

​       private int xPos, yPos, dimension;

​       private static Random rand = new Random(47);

​       private static int counter = 0;

​       public abstract void setColor(int newColor);

​       public abstract int getColor();

​       public Shape(int xVal, int yVal, int dim) {

​              xPos = xVal;

​              yPos = yVal;

​              dimension = dim;

​       }

​       public String toString() {

​              return getClass() + 

​                     " color[" + getColor() + "] xPos[" + xPos +

​                     "] yPos[" + yPos + "] dim[" + dimension + "]\n"; 

​       }

​       public static Shape randomFactory() {

​              int xVal = rand.nextInt(100);

​              int yVal = rand.nextInt(100);

​              int dim = rand.nextInt(100);

​              switch(counter++ % 3) {

​                     default:

​                     case 0: return new Circle(xVal, yVal, dim);

​                     case 1: return new Square(xVal, yVal, dim);

​                     case 2: return new Line(xVal, yVal, dim);

​              }

​       }

}

 

class Circle extends Shape {

​       private static int color = RED;

​       public static void serializeStaticState(ObjectOutputStream os)

​       throws IOException { os.writeInt(color); }

​       public static void deserializeStaticState(ObjectInputStream os) 

​       throws IOException { color = os.readInt(); }

​       public Circle(int xVal, int yVal, int dim) {

​              super(xVal, yVal, dim);

​       }

​       public void setColor(int newColor) { color = newColor; }

​       public int getColor() { return color; }

} 

 

class Square extends Shape {

​       private static int color;

​       public static void serializeStaticState(ObjectOutputStream os)

​       throws IOException { os.writeInt(color); }

​       public static void deserializeStaticState(ObjectInputStream os) 

​       throws IOException { color = os.readInt(); }

​       public Square(int xVal, int yVal, int dim) {

​              super(xVal, yVal, dim);

​              color = RED;

​       }

​       public void setColor(int newColor) { color = newColor; }

​       public int getColor() { return color; }

}

 

class Line extends Shape {

​       private static int color = RED;

​       public static void serializeStaticState(ObjectOutputStream os)

​       throws IOException { os.writeInt(color); }

​       public static void deserializeStaticState(ObjectInputStream os) 

​       throws IOException { color = os.readInt(); }

​       public Line(int xVal, int yVal, int dim) {

​              super(xVal, yVal, dim);

​       }

​       public void setColor(int newColor) { color = newColor; }

​       public int getColor() { return color; }

}

 

public class StoreCADState30 {

​       public static void main(String[] args) throws Exception {

​       List<Shape> shapes = new ArrayList<Shape>();

​             for(int i = 0; i < 10; i++)

​              shapes.add(Shape.randomFactory());

​             for(int i = 0; i < 10; i++)

​              ((Shape)shapes.get(i)).setColor(Shape.GREEN);

​             ObjectOutputStream out = new ObjectOutputStream(

​              new FileOutputStream("CADState.out"));

​       Circle.serializeStaticState(out);

​       Square.serializeStaticState(out);

​       Line.serializeStaticState(out);

​       out.writeObject(shapes);

​             System.out.println(shapes);

​       }

}

 

public class WordCountXML {

​       public static void format(OutputStream os, Document doc) 

​       throws Exception {

​              Serializer serializer = new Serializer(os, "ISO-8859-1");

​              serializer.setIndent(4);

​              serializer.setMaxLength(64);

​              serializer.write(doc);

​              serializer.flush();

​       }

​       public static void main(String[] args) {

​                           String fileName = "WordCountXML.java";

​                           Set<String> uniqueWords = 

​                     new TreeSet<String>(new TextFile(fileName, "\\W+"));

​                           ArrayList<String> allWords = new TextFile(fileName, "\\W+");

​              Map<String,Integer> wordCount = new TreeMap<String,Integer>();    

​                           for(String s : uniqueWords) {

​                     int count = 0;

​                     for(String t : allWords) {

​                            if(t.equals(s)) count++;

​                     }

​                     wordCount.put(s, count);

​              }

​              Element root = new Element("words");                        Iterator it = wordCount.entrySet().iterator();

​              while(it.hasNext()) {

​                     @SuppressWarnings("unchecked")

​                     Map.Entry<String,Integer> me = 

​                            (Map.Entry<String,Integer>)it.next();

​                     Element word = new Element("word");

​                     word.appendChild(me.getKey() + ": ");

​                     word.appendChild(Integer.toString(me.getValue()));

​                     root.appendChild(word);

​              }             

​              Document doc = new Document(root);

​                           try {        

​                     format(System.out, doc);

​                     format(new BufferedOutputStream(

​                            new FileOutputStream("WordCount.xml")), doc); 

​              } catch(Exception e) {

​                     System.err.println(e);

​              }

​       }

}

 

public class PreferencesDemo33 {

​       public static void main(String[] args) throws Exception {         

​              Preferences prefs = Preferences

​                     .userNodeForPackage(PreferencesDemo33.class);

​              int value = prefs.getInt("base directory", 0);

​              System.out.print("Base directory value = " + value +

​                     "\nEnter new base directory value (integer): ");

​              BufferedReader br = new BufferedReader(

​                     new InputStreamReader(System.in));

​              try {

​                     value = Integer.parseInt(br.readLine());

​                 } catch (Exception e) {

​                     System.err.println(e);

​                     System.exit(1);

​                 }

​              prefs.putInt("base directory", value);          

​       }

}