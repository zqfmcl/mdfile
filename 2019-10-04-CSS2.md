---
title: CSS2
date: 2019-10-04 10:00:00
tags: Javascript
---

# 2016年4月1日

## js

### constructor 属性

对象的`constructor`属性用于返回创建该对象的函数，也就是我们常说的**构造函数**。

```js
// 字符串：String()
var str = "张三";
document.writeln(str.constructor); // function String() { [native code] }
document.writeln(str.constructor === String); // true

// 数组：Array()
var arr = [1, 2, 3];
document.writeln(arr.constructor); // function Array() { [native code] }
document.writeln(arr.constructor === Array); // true

// 数字：Number()
var num = 5;
document.writeln(num.constructor); // function Number() { [native code] }
document.writeln(num.constructor === Number); // true

// 自定义对象：Person()
function Person(){
    this.name = "CodePlayer";
}
var p = new Person();
document.writeln(p.constructor); // function Person(){ this.name = "CodePlayer"; }
document.writeln(p.constructor === Person); // true

// JSON对象：Object()
var o = { "name" : "张三"};
document.writeln(o.constructor); // function Object() { [native code] }
document.writeln(o.constructor === Object); // true

// 自定义函数：Function()
function foo(){
    alert("CodePlayer");
}
document.writeln(foo.constructor); // function Function() { [native code] }
document.writeln(foo.constructor === Function); // true

// 函数的原型：bar()
function bar(){
    alert("CodePlayer");
}
document.writeln(bar.prototype.constructor); // function bar(){ alert("CodePlayer"); }
document.writeln(bar.prototype.constructor === bar); // true
```

> 代码中的`[native code]`这是JavaScript的底层内部代码实现，无法显示代码细节。

[TOC]

# 2016年4月4日

## angularjs

```js
$scope.$watch($scope.sum,function(newVal,oldVal){
        //console.log(newVal);
        //console.log(oldVal);
        
        $scope.iphone.fre = newVal >= 100 ? 0 : 10;
        
    });
```

三个参数：
第一个是监听的参数，第二个触发时执行的函数，有两个参数，旧值以及新值；第三个是为**true**时整体监听。

```js
var m1 = angular.module('myApp',[]);
m1.controller('Aaa',function($scope){
    $scope.name = 'hello';
});

//上下意思一样
var m1 = angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($s){
    $s.name = 'hello';
}]);
```

- angular.bind()

改变this的指向。

- angular.copy()

拷贝对象。

```
var c=angular.copy(a,b);
```

a全部拷贝覆盖b；

- angular.extend()

拷贝继承，不覆盖。

- angular.equals()

判读两个变量是否相等。

- angular.forEach

遍历循环

```js
var values = {'name':'hello','age':'20'};
var result = [];
angular.forEach(values,function(value,i){
    //console.log(value);
    //console.log(i);
    this.push( value + i );
},result);
console.log(result);
```

- angular.identity/noop()

返回调用的参数。

```js
var str = 'hello';
console.log(angular.identity(str));  //hello
```

- angular.lowercase/uppercase()

字符串转成大写或者小写。

- angular.element()

```js
var oDiv = document.getElementById('div1');

angular.element('#div1').css('background','red');
```

可以进一步使用jQuery的方式调用。

- 动态初始化

```js
var m1=angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
    $scope.name = 'hello';
}]);

document.onclick=function(){
    angular.bootstrap(document,['myApp']);
}

<div ng-controller="Aaa">
    <div>{{name}}</div>
</div>
```

点击后显示。

- angular.injector()

注册器，内部使用。

低分段

## css

使用语义化方式为CSS命名可以像这样:

<pre>
    container{…}
/*—- Top section —-*/
    #header{…}
    #navbar{…}
    /*—- Main —-*/
    #menu{…}
    #main{…}
    #sidebar{…}
    /*—- Footer —-*/
    #footer{…}

</pre>

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/css-01.jpg)

> http://blog.bingo929.com/CSS-coding-semantic-naming.html

[TOC]

# 2016年4月5日

## angularjs

- $scope.$apply()

```js
function Aaa($scope){
    $scope.name = 'hello';
    setTimeout(function(){
        $scope.$apply(function(){
            $scope.name = 'hi';
        });
    },2000);

    //另一种写法
    //
    setTimeout(function(){
        $scope.name = 'BBR';
        $scope.$apply();        
    },2000);
}
```

这个方法监听数据有没有变化，当数据发生变化，就会影响视图。

- angular.module
  - controller //方法
  - run
    - 不引入控制器，挂载全局变量

```js
var m1 = angular.module('myApp',[]);

m1.run(['$rootScope',function($rootScope){
    $rootScope.name = 'hello';
}]);
```

> 只能挂载全局作用域变量，不能调用局部变量。

- 过滤器/ currency

```js
<script>

var m1 = angular.module('myApp',[]);

/*自定义过滤器*/
/*m1.filter('firstUpper',function(){
    return function(str,num){//通过return返回过滤后的结果
        //console.log(num);//传参
        return str.charAt(0).toUpperCase() + str.substring(1);
    }
});*/

m1.controller('Aaa',['$scope','$filter',function($scope,$filter){
    
    $scope.name = '723894734.7489545';
    //$scope.name = 'hello';
    //$scope.name = {"name":"hello","age":"20"};
    //$scope.name = ['a','b','c'];
    //$scope.name = '3748935795';
    
    /*$scope.name = [
        {color:"red",age:"20"},
        {color:"yellow",age:"30"},
        {color:"blue",age:"40"},
        {color:"green",age:"10"}
    ];*/
    
    //$scope.name = $filter('uppercase')('hello');
    //$scope.name = $filter('number')('236478234.3647348',1);//转数字，限制一位。
    // $scope.name = $filter('date')('2364782342');//Jan 28, 1970
    
    // $scope.name = 'hello';
    // 
    //$scope.name = $filter('firstUpper')('hello');
    

}]);



</script>
</head>
```

```html
<div ng-controller="Aaa">

    <!-- 前面调价符号 -->
    <!-- <p>{{name | currency:"￥"}}</p> -->

    <!-- 保留一定长度的小数 -->
    <p>{{ name | number : 3}}</p>

    <!-- 全部大写 -->
    <!--<p>{{ name | uppercase }}</p>-->

    <!-- 以JSON格式展示数据 -->
    <!--<pre>{{ name | json }}</pre>-->

    <!-- 截取前两位 -->
    <!--<p>{{ name | limitTo : 2 }}</p>-->

    <!-- 日期展示格式 -->
    <!--<p>{{ name | date : 'yyyy' }}</p>-->

    <!-- 排序,或者倒序 -->
    <!--<p>{{ name | orderBy : 'age' : true }}</p>-->

    <!-- 过滤其他元素，只保留包含参数的字符串。 -->
    <!-- <p>{{ name | filter : 'l' }}</p> -->

    <!-- <p>{{ name | limitTo : 2 | uppercase }}</p> -->
    <!-- 截取一定长度数组或者字符串。 -->

    <!-- 自定义过滤器 -->
    <!--<p>{{ name | firstUpper : 2 }}</p>-->
    <!-- <p>{{ name }}</p> -->
</div>
  
```

[TOC]

# 2016年4月6日

## javascript

每隔一个字母就变成大写。

```js
function (str){
        var len=str.length;
        var arr=[];
        var newStr="";
        var cc="";
        for(var i=0;i<len;i++){
            if(i%2==0){
                //str[i]=str[i].toUpperCase()
                cc+=newStr.concat(str[i].toUpperCase());
                //arr.push(str[i].toUpperCase());
            }else{
                //arr.push(str[i]);
                cc+=newStr.concat(str[i]);
            }
        }
        //strs=arr.join("");
        return cc;
    }
```



[TOC]

# 2016年4月7日

## markdown

一下是一段流程图的语句，显示成代码形式的代表不支持markdown流程图解释。

```flow
st=>start: Start
e=>end
op=>operation: My Operation
cond=>condition: Yes or No?

st->op->cond
cond(yes)->e
cond(no)->op

```

[TOC]

# 2016年4月11日

## angularjs

**angularJs的指令**

- ng-disabled
  - 服务 $interval
- ng-readonly
- ng-checked
  - 是否选中。
- ng-value
  - input的value值，ng-value在没有加载数据，内容为空。

**数据加载显示指令**

- ng-bind

```html    
<div ng-bind="text"></div>

```

数据加载完再加载视图，但只支持一个表达式。

- ng-bind-template

可以添加多表达式。

```
<div ng-bind-template="{{text}},{{text}}"></div>
```

- ng-bind-html

```
//使用这个功能需要添加额外的插件。
    $scope.text = '<h1>hello</h1>';

//把字符串当做html文本来解释。
    <div ng-bind-html="text"></div>
```

- ng-cloak

当这个指令还没有解释完成，就会隐藏，当解释完成才会显示出来。

```
< div ng-cloak >{{text}}< /div >
```

- ng-non-bindable

不去解释这个表达式。

```
<div ng-non-bindable>{{text}}</div>
```

**样式属性相关指令**

- ng-class
- ng-style
- ng-href
- ng-src
- ng-attr-(suffix)

```js
var m1 = angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
    $scope.text = 'hello';
    $scope.style = "{color:'red',background:'yellow'}";
    $scope.sClass = "{red:true,yellow:true}";
    $scope.url = "http://www.baidu.com";
}]);

```

```html
<style>
.red{ background:red;}
.yellow{ background:yellow;}
</style>

<div ng-controller="Aaa">
    <div ng-class="{red:true}">{{text}}</div>
    <div ng-class="{{sClass}}">{{text}}</div>

    <div ng-style="{color:'red',background:'yellow'}">{{text}}</div>
    <div ng-style="{{style}}">{{text}}</div>

    <a ng-href="{{url}}">aaaaaaa</a>
    <a ng-href="{{'http://www.baidu.com'}}">Baidu</a>

    <!-- 自定义属性前缀 -->
    <a ng-attr-href="{{url}}" ng-attr-title="{{text}}" ng-attr-class="" ng-attr-style="">aaaaaaa</a>
    <a ng-attr-href="{{url}}" ng-attr-title="{{text}}" ng-attr-class="" ng-attr-style="">aaaaaaa</a>
</div>
```

**DOM相关操作指令**

- ng-show
  - true为显示。
- ng-hide
  - true为隐藏
- ng-if
  - 通过DOM添加或者删除这个标签。
- ng-swtich
  - on
  - default
    - 首先显示默认的。
  - when
    - 然后根据默认值变化切换。
- ng-open
  - 针对details标签，



```js
var m1 = angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){

    $scope.bBtn = true;

}]);

```

```html
<div ng-controller="Aaa">
    <input type="checkbox" ng-model="bBtn">
    <div ng-show="bBtn">aaaaaaaaaaaa</div>
    <div ng-if="bBtn">aaaaaaaaaaaa</div>
    <div ng-switch on="bBtn">
        <p ng-switch-default>默认的效果</p>
        <p ng-switch-when="false">切换的效果</p>
    </div>

    <details ng-open="bBtn">
        <summary>Copyright 2011.</summary>
        <p>All pages and graphics on this web site are the property of W3School.</p>
    </details>

</div>
```

**初始化数据指令**

- ng-init
  - 标签内定义一下数据。

```html
div ng-controller="Aaa" ng-init="text='hello'">
    {{ text }}
</div>-->
```

```html
<div ng-controller="Aaa">
    <div ng-repeat="arrOuter in arr" ng-init="outerIndex = $index">
        <div ng-repeat="arrInner in arrOuter" ng-init="innerIndex = $index">
            <p>{{arrInner}}:{{outerIndex}}{{innerIndex}}</p>
        </div>
    </div>
</div>
```

- ng-include
  - 引入其他文件嵌套到当前页面。

```html
<div ng-app="myApp" ng-controller="Aaa" ng-include="'temp.html'">
</div>
```

- ng-model
  - ng-model-options
  - updateOn
    - 数据什么时候更新的一个选项，可以选择光标离开等。

```html
<input type="text" ng-model="text" ng-model-options="{updateOn : 'blur'}">
<div>{{text}}</div>
```

- ng-controller
  - as
    - 绑定一个构造函数，然后在指令中可以创建一个对象。

```js
var m1 = angular.module('myApp',[]);
m1.controller('Aaa',['$scope',FnAaa]);

function FnAaa($scope){
}
FnAaa.prototype.num = '123';
FnAaa.prototype.text = 'hello';
FnAaa.prototype.show = function(){
    return 'angularJS';
};
```

```html
<div ng-controller="FnAaa as a1">
    <div>{{a1.text}}:{{a1.show()}}</div>
</div>
```

# 2016年4月12日

## javascript

### document.write 和writeln区别

**document.write()**:将内容写入文档，当前编辑位置为写入的内容的后一个字符。 
**document.writeln()**:将内容写入文档，并添加一个换行符，当前编辑位置为写入的内容的后一行的的起始位置。 

```js
with(window.open()){ 
document.write("百度")
document.write("百度")
document.write("百度")
document.writeln("知道")
document.writeln("知道")
document.writeln("知道")
} 
```

**效果**

```
百度百度知道
知道
知道
```

### for in循环与for循环

**for...in **语句用于对数组或者对象的属性进行循环操作。

```js
语法：
for (变量 in 对象)
{
    在此执行代码
}

```

**for循环**是对数组的元素进行循环，而不能引用于非数组对象。

```js
语法：
for(int 变量初始值;条件;递增或递减){
    在此执行代码
}
```

### 类型转换

#### Number函数

> 数值：转换后还是原来的值。

> 字符串：如果可以被解析为数值，则转换为相应的数值，否则得到NaN。空字符串转为0。

> 布尔值：true转成1，false转成0。

> undefined：转成NaN。

> null：转成0。



```js
Number("324") // 324

Number("324abc") // NaN

Number("") // 0

Number(false) // 0

Number(undefined) // NaN

Number(null) // 0
```

#### String函数：强制转换成字符串

> 数值：转为相应的字符串。

> 字符串：转换后还是原来的值。

> 布尔值：true转为“true”，false转为“false”。

> undefined：转为“undefined”。

> null：转为“null”。

```js
String(123) // "123"

String("abc") // "abc"

String(true) // "true"

String(undefined) // "undefined"

String(null) // "null"
```

#### Boolean函数：强制转换成布尔值

> undefined
> null
> -0
> +0
> NaN
> ’‘（空字符串）

```js
Boolean(undefined) // false

Boolean(null) // false

Boolean(0) // false

Boolean(NaN) // false

Boolean('') // false
```

## angular

### 标签指令

- < a>
  - 会阻止默认行为
- < select>
  - ng-options
    - for   in

```html
<!-- 循环数组对象 -->
<select ng-options="names.name for names in colors" ng-model="tn"></select>

<!-- 循环数组 -->
<select ng-options="names for names in name" ng-model="tn2"></select>


$scope.activities =
    [
        { id: 1, type: "Work", name: "Writing code" },
        { id: 2, type: "Work", name: "Testing code" },
        { id: 3, type: "Work", name: "Fixing bugs" },
        { id: 4, type: "Play", name: "Dancing" }
    ];        
<select ng-model="engineer.currentActivity" 
        data-ng-options="a.name group by a.type for a in activities">                
</select>
```

必须要有`ng-model`,这样才能加载数据。

- < textarea>
- < input>
  - 可以添加表单认证。
- < form>
  - novalidate
    - 阻止表单默认的验证样式

### ngularJs的表单验证

表单验证通过才通过双向数据绑定刷新视图。

- $valid
  - 数据有效返回true
- $invalid
  - 数据无效返回true
- $pristine
  - 是否为原始值，是就返回true
- $dirty
  - 修改后返回true。
- $error
  - 验证失败就会返回错误信息。
    - http://www.cnblogs.com/rohelm/p/4033513.html
- 注意点
  - name的方式进行查找
  - 要写ng-model

- equired
  - 必填，false表示验证通过。
- g-minlength
  - 最小长度，通过为false。

- g-maxlength
  - 最大长度，通过为false。

- g-pattern
  - 匹配正则，通过为false。

```html
<form novalidate name="myForm">
        <input type="email" name="myText" ng-model="text" required ng-minlength="5" ng-pattern="/^[a-zA-Z]+$/">
        <div> myForm.myText.$valid：{{ myForm.myText.$valid }}</div>
        <div>myForm.myText.$invalid ：{{ myForm.myText.$invalid }}</div>
        <div>myForm.myText.$pristine：{{ myForm.myText.$pristine }}</div>
        <div> myForm.myText.$dirty ：{{ myForm.myText.$dirty }}</div>
        <div>myForm.myText.$error ：{{ myForm.myText.$error }}</div>
    </form>
```

- 添加class
  - .ng-valid{}
  - .ng-invalid{}
  - .ng-pristine{}
  - .ng-dirty{}

```css
.txt.ng-valid{ border:1px green solid; background:#e55;}
.txt.ng-invalid{ border:1px red solid; background:blue;}
```

[TOC]

# 2016年4月13日

## angularjs

### angularJs的自定义指令

- angular.module
  - controller
  - run
    - 挂载全局的变量。
  - filter
  - directive
    - restrict的四种定义方式
      - E 只限元素名使用
      - A 只限属性使用
      - C 只限类名使用
        - 必须设置 restrict 的值为 "C" 才能通过类名来调用指令。
      - M 只限注释使用
        - 必须设置 restrict 的值为 "M" 才能通过注释来调用指令。
        - 需要在该实例添加 replace 属性， 否则评论是不可见的。
      - restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。
    - replace
    - template
    - templateUrl

```html
<script>

var m1 = angular.module('myApp',[]);
m1.directive('myHello',function(){
    return {
        restrict : 'AECM',   //区分大小写，而且是可以组合使用的
        replace : true,
        template : '<div>hello angular</div>'
    };
});
m1.controller('Aaa',['$scope',function($scope){
}]);
</script>


<my-hello></my-hello>
<p my-hello></p>
<p class="my-hello"></p>
<!-- directive:my-hello -->
```

也可以引入外部文件：

```js
m1.directive('myTab',function(){
    return {
        restrict : 'E',   
        replace : true,
        templateUrl : 'temp2.html'
    };
});
```

- directive
  - scope
    - 独立作用域true
    - 隔离作用域{}
      - 在单独的标签里起作用。
      - @
      - =
      - &

```js
m1.directive('myTab',function(){
    return {
        restrict : 'E',   
        replace : true,
        //scope : true,
        //每一个标签元素都可以用ng-init定义独立的作用域。
        scope : {
            myId : '@',
            myName : '=',
            myFn : '&'
        },
        controller : ['$scope',function($scope){
            $scope.name = 'miaov';
        }],
        //引入第三方文件
        templateUrl : 'temp2.html'
    };
});
```

|    属性     | 描述                                                         |
| :---------: | ------------------------------------------------------------ |
|  restrict   | 决定一个指令可如何被使用（例如元素、属性、CSS class 或 注释）。 |
|    scope    | 用于创建一个子 scope 或孤立的 scope 。                       |
|  template   | 定义指令的输出内容。可以包含 HTML 、数据绑定表达式，甚至是其它指令。 |
| templateUrl | 提供指令所用模版的路径。如果模版被定义在 < script> 内，那它可以包含一个 DOM 元素的 id 。 |
| controller  | 用于定义和指令模版关联的控制器。                             |
|    link     | 用于 DOM 操作任务的函数                                      |

其中**隔离作用域**中的**变量**绑定到属性名称，属性中的值为字符串值、控制器中的变量或者函数。隔离作用域和属性的之间的绑定策略有如下三种：

- @：绑定的属性值为字符串。此时没有与controller交互。
- =：绑定的属性值为变量。此时与controller有交互。
- &：绑定的属性值为函数。此时与controller有交互。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/scope%E4%BD%9C%E7%94%A8%E5%9F%9F.jpg)

> http://blog.csdn.net/GAMEloft9/article/details/50848016

```html 
<script>

var m1 = angular.module('myApp',[]);
m1.directive('myTab',function(){
    return {
        restrict : 'E',   
        replace : true,
        //scope : true,
        scope : {
            myId : '@',//myId等于my-id,js标识符不支持横线（-），但可以转为驼峰命名法。绑定指定的字符串。
            myName : '=',//解释的是数据，
            myFn : '&'//绑定父级的函数
        },
        controller : ['$scope',function($scope){
            $scope.name = 'miaov';
        }],
        templateUrl : 'temp2.html'
    };
});

m1.controller('Aaa',['$scope',function($scope){
    
    $scope.name = 'hello';
    $scope.show = function(n){
        alert(n);
    };  
}]);
</script>



<body ng-controller="Aaa">
<!-- 留意传参的两种方式。 -->
<my-tab my-id="div1" my-name="name" my-fn="show('hello')"></my-tab>
<my-tab my-id="div2" my-name="name" my-fn="show(num)"></my-tab>
</body>
```

tab代码

```html
<div id="{{myId}}">
    <input class="active" type="button" value="1" ng-click="myFn({num:456})">
    <input type="button" value="2">
    <input type="button" value="3">
    <div style="display:block">{{name}}</div>
    <div>22222222</div>
    <div>33333333</div>
</div>
```

## javascript

### valueOf() 函数详解

**valueOf()**函数返回指定对象的原始值。

|   对象   | 返回值                                                       |
| :------: | :----------------------------------------------------------- |
|  Array   | 数组实例对象。                                               |
| Boolean  | 布尔值。                                                     |
|   Date   | 以毫秒数存储的时间值，从 UTC 1970 年 1 月 1 日午夜开始计算。 |
| Function | 函数本身。                                                   |
|  Number  | 数字值。                                                     |
|  Object  | 对象本身。这是默认设置。                                     |
|  String  | 字符串值。                                                   |

```js
// Array：返回数组对象本身
var array = ["CodePlayer", true, 12, -5];
document.writeln( array.valueOf() === array ); // true

// Date：当前时间距1970年1月1日午夜的毫秒数
var date = new Date(2013, 7, 18, 23, 11, 59, 230);
document.writeln( date.valueOf() ); // 1376838719230

// Number：返回数字值
var num =  15.26540;
document.writeln( num.valueOf() ); // 15.2654

// 布尔：返回布尔值true或false
var bool = true;
document.writeln( bool.valueOf() === bool ); // true
// new一个Boolean对象
var newBool = new Boolean(true);
// valueOf()返回的是true，两者的值相等
document.writeln( newBool.valueOf() == newBool ); // true
// 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型
document.writeln( newBool.valueOf() === newBool ); // false

// Function：返回函数本身
function foo(){ 
}
document.writeln( foo.valueOf() === foo ); // true
var foo2 =  new Function("x", "y", "return x + y;");
document.writeln( foo2.valueOf() === foo2 ); // true

// Object：返回对象本身
var obj = {name: "张三", age: 18};
document.writeln( obj.valueOf() === obj ); // true

// String：返回字符串值
var str = "http://www.365mini.com";
document.writeln( str.valueOf() === str ); // true
// new一个字符串对象
var str2 = new String("http://www.365mini.com");
// 两者的值相等，但不全等，因为类型不同，前者为string类型，后者为object类型
document.writeln( str2.valueOf() === str2 ); // false
```

### toString() 函数详解

**toString()**函数用于将当前对象以字符串的形式返回。

|     类型     | 行为描述                                                     |
| :----------: | ------------------------------------------------------------ |
|    Array     | 将 Array 的每个元素转换为字符串，并将它们依次连接起来，两个元素之间用英文逗号作为分隔符进行拼接。 |
|   Boolean    | 如果布尔值是true，则返回"true"。否则返回"false"。            |
|     Date     | 返回日期的文本表示。                                         |
|    Error     | 返回一个包含相关错误信息的字符串。                           |
|   Function   | 返回如下格式的字符串，其中 functionname 是一个函数的名称，此函数的 toString 方法被调用： "function functionname() { [native code] }" |
|    Number    | 返回数值的字符串表示。还可返回以指定进制表示的字符串，请参考Number.toString()。 |
|    String    | 返回 String 对象的值。                                       |
| Object(默认) | 返回"[object ObjectName]"，其中 ObjectName 是对象类型的名称。 |

```js
//数组
var array = ["CodePlayer", true, 12, -5];
document.writeln( array.toString() ); // CodePlayer,true,12,-5

// 日期
var date = new Date(2013, 7, 18, 23, 11, 59, 230);
document.writeln( date.toString() ); // Sun Aug 18 2013 23:11:59 GMT+0800 (中国标准时间)

// 日期2
var date2 = new Date(1099, 7, 18, 23, 11, 59, 230);
document.writeln( date2.toString() ); // Fri Aug 18 1099 23:11:59 GMT+0800 (中国标准时间)

// 数字
var num =  15.26540;
document.writeln( num.toString() ); // 15.2654

// 布尔
var bool = true;
document.writeln( bool.toString() ); // true

// Object
var obj = {name: "张三", age: 18};
document.writeln( obj.toString() ); // [object Object]

// HTML DOM 节点
var eles = document.getElementsByTagName("body");
document.writeln( eles.toString() ); // [object NodeList]
document.writeln( eles[0].toString() ); // [object HTMLBodyElement]
```

### typeof 操作符

typeof操作符返回一个字符串,表示未经求值的操作数(unevaluated operand)的类型。

| 类型                                                 | 结构                     |
| :--------------------------------------------------- | ------------------------ |
| Undefined                                            | "undefined"              |
| Null                                                 | "object" (见下方)        |
| 布尔值                                               | "boolean"                |
| 数值                                                 | "number"                 |
| 字符串                                               | "string"                 |
| Symbol (ECMAScript 6 新增)                           | "symbol"                 |
| 宿主对象(JS环境提供的，比如浏览器)                   | Implementation-dependent |
| 函数对象 (implements \[\[Call\]\] in ECMA-262 terms) | "function"               |
| 任何其他对象                                         | "object"                 |

> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof

[TOC]

# 2016年4月15日

## angularjs

### 自定义指令directive

- transclude
  - ng-transclude
    - 默认为false，可以把其他指令嵌入当中。
- require
  - 把一个指令引入到其他指令，在下面的构造器中就可以使用这个指令构造器当中 的变量。
  - ^
    - 去父级找指令
  - ?
    - 如果不存在 ，不会报错。

```js
var m1 = angular.module('myApp',[]);
m1.directive('hello',function(){
    return {
        restrict:'E',
        replace:true,
        transclude:true, 
        controller:function($scope){
            this.name='niefee,hello';
        },
        template:'<div>nihao,<h1 ng-transclude></h1></div>' 
    };
});

m1.directive('hi',function(){
    return {
        restrict : 'E',   
        replace : true,
        require : '?^hello',    
        template : '<span>hi angular</span>',
        link:function(scope,element,attr,reController){

            console.log(reController.name);
        }
    }
});
```

```html
<hello>
    <hi></hi>
</hello>
```

### $http服务

- $http
  - method
  - url
  - success
    - data--返回的请求数据。
    - state--返回的状态值
    - headers--
    - config
  - error
  - 简写方式
    - jsonp
    - JSON_CALLBACK
  - 例子  :   百度下拉搜索



```js
/*$http({
        method:'GET',
        url:'data.php',

    }).success(function(data,state,hesders,config){
        console.log(data);
        console.log(state);
        console.log(hesders);
        console.log(config);
    }).error(function(data){
        document.write(data);
    })*/

    $http.get('data.php').success(function(data,stata,headers,config){
        console.log(data);
    })
```

### $location

- absUrl()
  - 绝对地址
- path()
  - 与路由挂钩
- replace()
  - 不会出现历史管理，没有返回。
- hash()
  - 哈希
- search()
- url()
  - 路径、哈希
- host()
  - 主机名
- port()
  - 端口
- protocol()
  - 协议

```js
    //var a = $location.absUrl();
    $location.path('aaa/bbb/ccc').replace();
    $location.hash('hello');
    //$location.search({'age':'20'});
    var a = $location.port();
    //var a = $location.protocol();
    console.log(a);
```

- $anchorScroll()
  - 例子  :  锚点跳转

```html
<script>

var m1 = angular.module('myApp',[]);
m1.controller('Aaa',['$scope','$location','$anchorScroll',function($scope,$location,$anchorScroll){
    
    $scope.change = function(id){
        
        //console.log(id);
        $location.hash(id);
        $anchorScroll();
        
    };
    
}]);

</script>


<div id="parent" ng-controller="Aaa">
    <ul>
        <li ng-repeat="id in [1,2,3,4,5]" ng-click="change('div'+id)">{{id}}aaaaaaaaaa</li>
    </ul>
    <div ng-repeat="id in [1,2,3,4,5]" ng-attr-id="div{{id}}">{{id}}</div>
</div>
```

- $cacheFactory
  - info()
  - put()
  - get()
  - remove()
  - 配置capacity



## javascript

### 节点操作

**添加节点**

```js
var para=document.createElement("p");
var node=document.createTextNode($scope.arr[i]);
para.appendChild(node);
```

**删除节点**

```js
var parent=document.getElementById("div1");
var child=document.getElementById("p1");
parent.removeChild(child);
```

[TOC]

# 2016年4月18日

## javascript

JavaScript的原生错误类型

- SyntaxError
  - SyntaxError是解析代码时发生的语法错误。
- ReferenceError
  - ReferenceError是引用一个不存在的变量时发生的错误。
  - 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。
- RangeError
  - RangeError是当一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。
- TypeError
  - TypeError是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。
- URIError
  - URIError是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。
- EvalError
  - eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再在ES5中出现了，只是为了保证与以前代码兼容，才继续保留。

## angularjs

### $cacheFactory缓存服务

- info()
  - 缓存内容信息
- put()
  - 设置缓存
- get()
  - 获取缓存
- remove()
  - 删除缓存
- 配置capacity
  - 设置缓存长度

```js
m1.controller('Acon',['$scope','$cacheFactory',function($scope,$cacheFactory){
    var cache=$cacheFactory('myCache');

    console.log(cache.info());

    cache.put('name','hello');
    cache.put('age','20');

    console.log(cache.get('name'));
}]) 
```

### $log服务

- log()
  - 打印
- info()
  - 打印信息
- warn()
  - 警告信息
- error()
  - 错误信息

```js
m1.controller('Aaa',['$scope','$log',function($scope,$log){
    
    $log.log('hello');
    $log.info('hello');
    $log.warn('hello');
    $log.error('hello');
}]);
```

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/log.jpg)

### $interpolate

插值计算

```html
<script>
var m1 = angular.module('myApp',[]);
m1.controller('Aaa',['$scope','$interpolate',function($scope,$interpolate){ 
    $scope.$watch('body',function(newBody){     
        if(newBody){
            var temp = $interpolate(newBody);
            $scope.showText = temp({ name : $scope.name });         
        }       
    }); 
}]);
</script>

<div ng-controller="Aaa">
    <input type="text" ng-model="name">
    <textarea ng-model="body">
    </textarea>
    <p>{{showText}}</p>
</div>
```

### 供应商概念

- 服务的相关初始配置操作
- config
  - provider
  - $interpolate
    - startSymbol()
      - 表达式头部标识
    - endSymbol()
      - 表达式尾部标示
  - $log
    - debugEnabled()
      - 禁用某功能
  - $anchorScroll
    - disableAutoScrolling()
      - 禁止在地址栏自动跳转

### **$q**延迟对象

- promise的实现
- defer()
- resolve()
  - 成功
- reject()
  - 失败
- notify()
- then()

### 自定义服务

- module
  - filter()
  - directive()
  - factory()
  - provider()
    - 区别
    - $get

```js
var m1 = angular.module('myApp',[]);
m1.factory('myService',function(){

    return {
        name:'efee',
        show:function(){
            return this.name+':angular';
        }
    }
})
m1.controller('Acon',['$scope','myService',function($scope,myService){
    console.log(myService.show());
}]) 
```

- 模块之间的通信
  - provide好处
- service()
  - 构造函数
- constant()
  - 设置常量
- value()
  - 区别

### angularjs插件

- ngSanitize
- ngRoute
  - 版本的问题
  - ng-view
    - 这个插件特有。
  - $routeProvider
    - when
      - template
      - templateUrl



[TOC]

# 2016年4月19日

## angularjs

### 内部传播方式

- $emit
  - 向上广播
- $broadcast
  - 向下广播
- event
  - targetScope
    - 点击目标
  - currentScope
    - 当前目标
  - name
    - 事件名称
  - stopPropagation()
    - 阻止冒泡
- 内部传播方式
  - $routeChangeStart
  - $viewContentLoaded

### 运动插件

- CSS3的方式
- ng-enter
  - 运动进入开始
- ng-enter-active
  - 运动进入结束
- ng-leave
  - 运动离开开始
- ng-leave-active
  - 运动离开结束
- 支持的指令
  - if,view,repeat,include,swtich
  - repeat
    - ng-enter-stagger
    - animation-delay

```css
.box{ transition:1s all;}
.box.ng-enter{ opacity:0;}
.box.ng-enter-active{ opacity:1;}
.box.ng-leave{ display:none;}
.box.ng-enter-stagger{
    animation-delay : 100ms;
}
```

- ng-hide-add
- ng-hide-add-active
- ng-hide-remove
- ng-hide-remove-active
- 支持的指令
  - class,show,hide,model等

```css
.box{ width:200px; height:200px; background:red; transition:1s all;}
.box.ng-hide-remove{ opacity:0;}
.box.ng-hide-remove-active{ opacity:1;}
.box.ng-hide-add{ opacity:1;}
.box.ng-hide-add-active{ opacity:0;}
```

- JS方式
  - animation()
  - enter/leave
  - removeClass/addClass

```js
m1.animation('.box',function(){
    return {
        addClass : function(element,sClass,done){
            //console.log(element);
            //console.log(sClass);
            //console.log(done);
            $(element).animate({width:0,height:0},1000,done);
        },
        removeClass : function(element,sClass,done){
            $(element).css({width:0,height:0});
            $(element).animate({width:200,height:200},1000,done);
        }
    };
});
```

### ngResource

支持 RESTful 架构模式

- get()

  - 获取的内容

- query()

  - 区别

- save()

- delete()

  

[TOC]

# 2016年4月20日

## javascript

### apply()与call()

函数属性的继承与传递

```js
    /*定义一个人类*/
    function Person(name,age)
    {
        this.name=name;
        this.age=age;
    }
    /*定义一个学生类*/
    function Student(name,age,grade)
    {
        Person.apply(this,arguments);
        this.grade=grade;
    }
    //创建一个学生类
    var student=new Student("qian",21,"一年级");
    //测试
    alert("name:"+student.name+"\n"+"age:"+student.age+"\n"+"grade:"+student.grade);
    //大家可以看到测试结果name:qian  age:21  grade:一年级
    //学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.
```

**Function.apply(obj,args)**方法能接收两个参数
**obj**：这个对象将代替Function类里this对象,将调用函数**Person**里的**this**变成函数**Student**的**this**。
**args**：这个是数组，它将作为参数传给Function（args-->arguments）

> 在Studen函数里面可以将apply中修改成如下:

> > Person.call(this,name,age);

### 函数的声明

- function命令

```js
function print(s) {
  console.log(s);
}  
```

> 上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。

- 函数表达式

```js
var print = function(s) {
  console.log(s);
};
```

> 这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。

```
var f = function f() {};
```

> 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。

- Function构造函数

```js
 var add = new Function(
  'x',
  'y',
  'return (x + y)'
);

// 等同于

function add(x, y) {
  return (x + y);
}
```

> 在上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。

### 函数内部的变量提升

var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。

```js
function foo(x) {
  if (x > 100) {
    var tmp = x - 100;
  }
}
```

上面的代码等同于

```js
function foo(x) {
  var tmp;
  if (x > 100) {
    tmp = x - 100;
  };
}
```

### 函数本身的作用域

函数本身也是一个值，也有自己的作用域。它的作用域绑定其声明时所在的作用域。

```js
var a = 1;
var x = function () {
  console.log(a);
};

function f() {
  var a = 2;
  x();
}

f() // 1
```

函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。

### 函数值传递方式

函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。

```js
var p = 2;

function f(p) {
  p = 3;
}
f(p);

p // 2
```

如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。

```js
var obj = {p: 1};

function f(o) {
  o.p = 2;
}
f(obj);

obj.p // 2
```

如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。

```js
var obj = [1, 2, 3];

function f(o){
  o = [2, 3, 4];
}
f(obj);

obj // [1, 2, 3]
```

如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。

```
function f(p) {  window[p] = 2;}
```

### arguments对象

虽然arguments很像数组，但它是一个对象。

下面是两种常用的转换方法：slice方法和逐一填入新数组。

```js
var args = Array.prototype.slice.call(arguments);

// or

var args = [];
for (var i = 0; i < arguments.length; i++) {
  args.push(arguments[i]);
}
```

**callee属性**

arguments对象带有一个callee属性，返回它所对应的原函数。

```js
var f = function(one) {
  console.log(arguments.callee === f);
}

f() // true
```

### 闭包

函数内的函数。

```js
function f1() {
  var n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}

var result = f1();
result(); // 999
```

JavaScript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。

闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。

```js
function createIncrementor(start) {
  return function () {
    return start++;
  };
}

var inc = createIncrementor(5);

inc() // 5
inc() // 6
inc() // 7
```

外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。

### 立即调用的函数表达式（IIFE）

```js
(function(){ /* code */ }()); 

// 或者

(function(){ /* code */ })(); 
```

让引擎知道，圆括号前面的部分不是函数定义语句，而是一个表达式，这样就可以对此进行运算。

```js
var i = function(){ return 10; }();

true && function(){ /* code */ }();

0, function(){ /* code */ }();
!function(){ /* code */ }();

~function(){ /* code */ }();

-function(){ /* code */ }();

+function(){ /* code */ }();

new function(){ /* code */ }

new function(){ /* code */ }() // 只有传递参数时，才需要最后那个圆括号。

```

一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

### eval命令

eval命令的作用是，将字符串当作语句执行。

```js
eval('var a = 1;');

a // 1
```



[TOC]

# 2016年4月21日

## SASS

### 安装

第一步：移动默认的源

```
gem sources --remove https://rubygems.org/
```

第二步：指定淘宝的源

```
gem sources -a https://ruby.taobao.org/
```

第三步：查看指定的源是不是淘宝源

```
gem sources -l
```

删除Sass

```
gem uninstall sass
```

### Sass 和 SCSS

- 文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名
- 语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。

### 命令编译

单文件编译：

```
sass <要编译的Sass文件路径>/style.scss:<要输出CSS文件路径>/style.css
```

多文件编译：

```
sass sass/:css/
```

开启“watch”功能，这样只要你的代码进行任保修改，都能自动监测到代码的变化，并且给你直接编译出来：

```
sass --watch <要编译的Sass文件路径>/style.scss:<要输出CSS文件路径>/style.css
```

### 变量声明

- 声明变量的符号“$”
- 变量名称
- 赋予变量的值

> 如果值后面加上!default则表示默认值。

```
$brand-primary : darken(#428bca, 6.5%) !default; // #337ab7
```

### 全局变量与局部变量

```css
//SCSS
$color: orange !default;
//定义全局变量(在选择器、函数、混合宏...的外面定义的变量为全局变量)
.block {
  color: $color;//调用全局变量
}
em {
  $color: red;//定义局部变量
  a {
    color: $color;//调用局部变量
  }
}
span {
  color: $color;//调用全局变量
}
```

### 嵌套

- **选择器嵌套**

```css
nav {
  a {
    color: red;

    header & {
      color:green;
    }
  }  
}
```

编译后

```css
nav a {
  color:red;
}

header nav a {
  color:green;
}
```

- **属性嵌套**

```css
.box {
  border: {
   top: 1px solid red;
   bottom: 1px solid green;
  }
}
```

编译后：

```css
.box {
    border-top: 1px solid red;
    border-bottom: 1px solid green;
}
```

- **伪类嵌套**

```css
.clearfix{
&:before,
&:after {
    content:"";
    display: table;
  }
&:after {
    clear:both;
    overflow: hidden;
  }
}
```

编译后：

```css
clearfix:before, .clearfix:after {
  content: "";
  display: table;
}
.clearfix:after {
  clear: both;
  overflow: hidden;
}
```

### 声明混合宏

在 Sass 中，使用“@mixin”来声明一个混合宏。如：

```css
@mixin border-radius($radius:5px){
    -webkit-border-radius: $radius;
    border-radius: $radius;
}
```

调用：

```css
button {
    @include border-radius;
}
```

编译出来的 CSS:

```css
button {
  -webkit-border-radius: 3px;
  border-radius: 3px;
}
```

在混合宏中，可以传一个不带任何值的参数，在调用的时候可以给这个混合宏传一个参数值：

```css
.box {
  @include border-radius(3px);
}
```

### 继承

在 Sass 中是通过关键词 **@extend**来继承已存在的**类样式块**，从而实现代码的继承。

```css
//SCSS
.btn {
  border: 1px solid #ccc;
  padding: 6px 10px;
  font-size: 14px;
}

.btn-primary {
  background-color: #f36;
  color: #fff;
  @extend .btn;
}

.btn-second {
  background-color: orange;
  color: #fff;
  @extend .btn;
}
```

编译后：

```css
//CSS
.btn, .btn-primary, .btn-second {
  border: 1px solid #ccc;
  padding: 6px 10px;
  font-size: 14px;
}

.btn-primary {
  background-color: #f36;
  color: #fff;
}

.btn-second {
  background-clor: orange;
  color: #fff;
}
```

```css
%mt5 {
  margin-top: 5px;
}
%pt5{
  padding-top: 5px;
}
.btn {
  @extend %mt5;
  @extend %pt5;
}
```

> 因为 %placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/SASS.jpg)

```css
//SCSS中混合宏使用
@mixin mt($var){
  margin-top: $var;  
}

.block {
  @include mt(5px);

  span {
    display:block;
    @include mt(5px);
  }
}

.header {
  color: orange;
  @include mt(5px);

  span{
    display:block;
    @include mt(5px);
  }
}

//SCSS 继承的运用
.mt{
  margin-top: 5px;  
}

.block {
  @extend .mt;

  span {
    display:block;
    @extend .mt;
  }
}

.header {
  color: orange;
  @extend .mt;

  span{
    display:block;
    @extend .mt;
  }
}

//SCSS中占位符的使用
%mt{
  margin-top: 5px;  
}

.block {
  @extend %mt;

  span {
    display:block;
    @extend %mt;
  }
}

.header {
  color: orange;
  @extend %mt;

  span{
    display:block;
    @extend %mt;
  }
}
```





[TOC]

# 2016年4月23日

## CSS

### CSS hack

**CSS hack**
CSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，CSS hack就是让你记住这个标准），以达到应用不同的CSS样式的目的，比如.kwstu{width:300px; _ width:200px;}，一般浏览器会先给元素使用width:300px;的样式，紧接着后面还有个_width:200px;由于下划线_width只有IE6可以识别，所以此样式在IE6中实际设置对象的宽度为200px，后面的把前面的给覆盖了，而其他浏览器不识别_width不会执行_width:200px;这句样式，所以在其他浏览器中设置对象的宽度就是300px;

> margin属性在ie6中显示的距离会比其他浏览器中显示的距离宽2倍

**浏览器识别字符标准对应表**

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/ie.png)

从上图可以分析出以下几种情况：

1. 大部分特殊字符IE浏览器支持，其他主流浏览器firefox，chrome，opera，safari不支持 (opera可识别除外)。
2. \9    ：所有IE浏览器都支持
3. _和-  ：仅IE6支持
4. \*     ：IE6、E7支持
5. \0    ：IE8、IE9支持，opera部分支持
6. \9\0  ：IE8部分支持、IE9支持
7. \0\9  ：IE8、IE9支持

hack汇总

```css
.element{
color:#000;             /*w3c标准*/
[;color:#f00;];         /*Webkit(chrome和safari)*/
color:#666\9;           /*IE8*/
*color:#999;            /*IE7*/
_color:#333;            /*IE6*/
}
:root .element{color:#0f0\9;}  /*IE9*/
@-moz-document url-prefix(){ .element{color:#f1f1f1;}} /*Firefox*/
```

**html头部hack**

HTML头部引用(if IE)Hack：针对所有IE：< !--[if IE]>< !--您的代码-->< ![endif]-->，针对IE6及以下版本：< !--[if lt IE 7]>< !--您的代码-->< ![endif]-->，这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。

```html
只在IE下生效
<!--[if IE]>
这段文字只在IE浏览器显示
<![endif]-->
只在IE6下生效
<!--[if IE 6]>
这段文字只在IE6浏览器显示
<![endif]-->
只在IE6以上版本生效
<!--[if gte IE 6]>
这段文字只在IE6以上(包括)版本IE浏览器显示
<![endif]-->
```

**选择器前缀hack**

```
*html *前缀只对IE6生效

*+html *+前缀只对IE7生效

@media screen\9{...}只对IE6/7生效

@media \0screen {body { background: red; }}只对IE8有效

@media \0screen\,screen\9{body { background: blue; }}只对IE6/7/8有效

@media screen\0 {body { background: green; }} 只对IE8/9/10有效

@media screen and (min-width:0\0) {body { background: gray; }} 只对IE9/10有效

@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效等等
```

> http://blog.csdn.net/freshlover/article/details/12132801

[TOC]

# 2016年4月24日

## http

### http状态码

- **消息（1字头）**

这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。

| 状态代码 | 状态信息            | 含义                                                         |
| -------- | ------------------- | ------------------------------------------------------------ |
| 100      | Continue            | 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新） |
| 101      | Switching Protocols | 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）       |

- **成功（2字头）**

这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。

| 状态代码 | 状态信息 | 含义                                            |
| -------- | -------- | ----------------------------------------------- |
| 200      | OK       | 一切正常，对GET和POST请求的应答文档跟在后面。   |
| 201      | Created  | 服务器已经创建了文档，Location头给出了它的URL。 |
| 202      | Accepted | 已经接受请求，但处理尚未完成。                  |
| ...      | ....     | ....                                            |

- **重定向（3字头）**

这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。
当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A->A，或者A->B->C->A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。

| 状态代码 | 状态信息          | 含义                                                         |
| -------- | ----------------- | :----------------------------------------------------------- |
| 300      | Multiple Choices  | 客户请求的文档可以在多个位置找到,这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 |
| 301      | Moved Permanently | 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 |
| ....     | ......            | ....                                                         |

- **请求错误（4字头）**

这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。

| 状态代码 | 状态信息     | 含义                                                         |
| -------- | ------------ | ------------------------------------------------------------ |
| 400      | Bad Request  | 请求出现语法错误。                                           |
| 401      | Unauthorized | 客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填 写合适的Authorization头后再次发出请求。 |
| 403      | Forbidden    | 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。 |
| 404      | Not Found    | 无法找到指定位置的资源。这也是一个常用的应答。               |
| ...      | ...          | ....                                                         |

- **服务器错误（5、6字头）**

这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。

| 状态代码 | 状态信息              | 含义                                                         |
| -------- | --------------------- | ------------------------------------------------------------ |
| 500      | Internal Server Error | 服务器遇到了意料不到的情况，不能完成客户的请求。             |
| 501      | Not Implemented       | 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。 |
| 502      | Bad Gateway           | 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 |
| ...      | ...                   | ...                                                          |

> http://baike.baidu.com/link?url=xxCnJ3Knmcn4J2aYhZeN7C4t9hUdkO6zNMc4HdgXD1oibXXEUT8i2ackqYUHazczyeOogOZDQLswFyYAqMA43a

## css

### line-height

- **line-height属性的细节**
  与大多数CSS属性不同，line-height支持属性值设置为无单位的数字。有无单位在子元素继承属性时有微妙的不同。
- **语法**
  line-height: normal | <number> | <length> | <percentage>
  normal 根据浏览器决定，一般为1.2。
  number 仅指定数字时（无单位），实际行距为字号乘以该数字得出的结果。可以理解为一个系数，子元素仅继承该系数，子元素的真正行距是分别与自身元素字号相乘的计算结果。大多数情况下推荐使用，可以避免一些意外的继承问题。
  length 具体的长度，如px/em等。
  percentage 百分比，100%与1em相同。
- **有单位（包括百分比）与无单位之间的区别**
  有单位时，子元素继承了父元素计算得出的行距；无单位时继承了系数，子元素会分别计算各自行距（推荐使用）。



[TOC]

# 2016年4月25日

## javascript

### 数值

JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。

```js
1 === 1.0 // true
1 + 1.0 // 2
```

由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。

```js
0.1 + 0.2 === 0.3
// false

0.3 / 0.1
// 2.9999999999999996

(0.3 - 0.2) === (0.2 - 0.1)
// false
```

> 浮点数：采用了IEEE-745浮点数表示法，可以精确地表示分数，遗憾的是，我们常用的分数（特别是在金融的计算方面）都是十进制分数1/10，1/100等。二进制浮点数表示法并不能精确的表示类似0.1这样 的简单的数字。

> http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html

- **数值的表示法**

以下两种情况，JavaScript会自动将数值转为科学计数法表示

1. 小数点前的数字多于21位。
2. 小数点后的零多于5个。

- **数值的进制**

使用字面量（literal）时，JavaScript对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。

1. 十进制：没有前导0的数值。
2. 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的七个阿拉伯数字的数值。
3. 十六进制：有前缀0x或0X的数值。
4. 二进制：有前缀0b或0B的数值。

- **NAN**

NaN是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。
    

```
typeof NaN // 'number'

isNaN(NaN) // true
```

> isNaN方法可以用来判断一个值是否为NaN。

判断NaN更可靠的方法是，利用NaN是JavaScript之中唯一不等于自身的值这个特点，进行判断。

```
function myIsNaN(value) {return value !== value;}
```

- **parseInt()**

**parseInt**方法用于将字符串转为整数。如果字符串头部有空格，空格会被自动去除。参数不是字符串，则会先转为字符串再转换。

```js
parseInt('8a') // 8
parseInt('12**') // 12
parseInt('12.34') // 12
parseInt('15e2') // 15
parseInt('15px') // 15
```

parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制,第二个参数默认为10。

```js
parseInt('1000') // 1000
parseInt('1000', 10) // 1000
```

如果第二个参数不是数值，会被自动转为一个整数。如果第二个参数是0、undefined和null，则直接忽略。

字符串包含对于指定进制无意义的字符，则返回NaN。

- **parseFloat()**

parseFloat方法用于将一个字符串转为浮点数。

```
parseFloat('314e-2') // 3.14
parseFloat('0.0314E+2') // 3.14 
```

如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。

```js
parseFloat([]) // NaN
parseFloat('FF2') // NaN
parseFloat('') // NaN

parseFloat('\t\v\r12.34\n ') // 12.34
```

### 原型

原型：CSS中Class

普通方法：CSS中的style

原型：prototype:要写在构造函数下面。

```js
var arr=[1,2,3,4,5];

Array.prototype.sum=function(){
    var result=0;
    for(var i=0;i<this.length;i++){
        result+=this[i];
    }

    return result;
}

alert(arr.sum());
    
```

面向对象的原型写法：

```js
function 构造函数(){
    this.属性
}

构造函数.原型.方法=function(){};

var 对象1=new 构造函数();
对象1.方法();
```

**Array.__proto__**提供的是 数组原型 – 请把它当作 Array 函数所继承的对象。

而**Array.protoype**，提供的的是 所有数组的原型对象。

```js
var Point = function (x, y) {
    this.x = x;
    this.y = y;
}
Point.prototype.add = function (otherPoint) {
    this.x += otherPoint.x;
    this.y += otherPoint.y;
}
var p1 = new Point(3, 4);
var p2 = new Point(8, 6);
p1.add(p2);
```

> http://blog.jobbole.com/66441/

> 资料参考：http://javascript.ruanyifeng.com/grammar/number.html 



[TOC]

# 2016年4月26日

## javascript

### 对象

所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。
对象的所有键名都是字符串，所以加不加引号都可以。

- 如果键名不符合标识名的条件（数字、空格或者运算符），也不是数字，则必须加上引号。
- JavaScript的保留字可以不加引号当作键名。
- 如果键名是数字，则会默认转为对应的字符串。

```js
'1p': "Hello World",

for: 1,

1e2: true//100: true   
```

#### 对象生成

```js
var o1 = {};
var o2 = new Object();
var o3 = Object.create(null);
```

#### 操作属性

读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。

```js
var o = {
  p: 'Hello World'
};

o.p // "Hello World"
o['p'] // "Hello World"
```

> 如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。但是，数字键可以不加引号，因为会被当作字符串处理。

```js
if(a) {...} // 报错

if(window.a) {...} // 不报错
if(window['a']) {...} // 不报错

if('a' in window) {//推荐 使用
  ...
}

```

所有全局变量都是window对象的属性。如果该属性不存在，就返回undefined，并不会报错。

**查看所有属性**

```js
var o = {
  key1: 1,
  key2: 2
};

Object.keys(o);
// ['key1', 'key2']
```

**删除属性**

```js
var o = {p: 1};
Object.keys(o) // ["p"]

delete o.p // true
o.p // undefined
Object.keys(o) // []
```

一旦使用delete命令删除某个属性，再读取该属性就会返回undefined，而且Object.keys方法返回的该对象的所有属性中，也将不再包括该属性。

#### 对象的引用

如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。

```js
var o1 = {};
var o2 = o1;
//o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。
o1.a = 1;
o2.a // 1

o2.b = 2;
o1.b // 2
```

```js
var o1 = {};
var o2 = o1;

o1 = 1;
o2 // {}
```

o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响。

#### in运算符

in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。

```js
var o = { p: 1 };
'p' in o // true
```

在JavaScript语言中，所有全局变量都是顶层对象（window）的属性。
in运算符的一个问题是，它不能识别对象继承的属性。

```js
var o = new Object();
o.hasOwnProperty('toString') // false

'toString' in o // true
```

> hasOwnProperty()函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。

#### for…in循环

for...in循环用来遍历一个对象的全部属性。
for...in循环遍历的是对象所有可enumberable的属性，包括对象本身的属性，还包括对象继承的属性

```js
// name 是 Person 本身的属性
function Person(name) {
  this.name = name;
}

// describe是Person.prototype的属性
Person.prototype.describe = function () {
  return 'Name: '+this.name;
};

var person = new Person('Jane');

// for...in循环会遍历实例自身的属性（name），
// 以及继承的属性（describe）
for (var key in person) {
  console.log(key);
}
// name
// describe
```

如果只想遍历对象本身的属性，可以使用hasOwnProperty方法:

```js
for (var key in person) {
  if (person.hasOwnProperty(key)) {
    console.log(key);
  }
}
// name
```

#### with语句

它的作用是操作同一个对象的多个属性时。

```js
// 例一
with (o) {
  p1 = 1;
  p2 = 2;
}
// 等同于
o.p1 = 1;
o.p2 = 2;

// 例二
with (document.links[0]){
  console.log(href);
  console.log(title);
  console.log(style);
}
// 等同于
console.log(document.links[0].href);
console.log(document.links[0].title);
console.log(document.links[0].style);
```

with区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。

```js
var o = {};

with (o) {
  x = "abc";
}

o.x // undefined
x // "abc"
```

### 数值

两个字符串进行比较时，按照字典顺序进行比较。
JavaScript引擎内部首先比较首字符的Unicode编号，如果相等，再比较第二个字符的Unicode编号，以此类推。

```js
'cat' > 'Cat' // true'
```

小写的c的Unicode编号（99）大于大写的C的Unicode编号（67）。

#### 同一类的复合类型值

两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。

```js
({}) === {} // false
[] === [] // false
(function (){}) === function (){} // false
```

严格相等运算比较的是它们的内存地址是否一样，而上面代码中空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是false。

#### 相等运算符

- 原始类型的值
  - 原始类型的数据会转换成数值类型再进行比较。
- 对象与原始类型值比较
  - 对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。

```js
[1] == 1 // true
[1] == '1' // true
[1] == true // true
```

> 上面代码将只含有数值1的数组与原始类型的值进行比较，数组[1]会被自动转换成数值1，因此结果都是true。

- undefined和null
  - undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。
- 相等运算符的缺点
  - 相等运算符隐藏的类型转换，会带来一些违反直觉的结果。

```js
'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true
```

#### 布尔运算符

取反运算符形式上是一个感叹号，用于将布尔值变为相反值。

以下六个值取反后为true：

```js
!undefined // true
!null // true
!false // true
!0 // true
!NaN // true
!"" // true
```

```js
!!x

// 等同于

Boolean(x)
```

#### 且运算符（&&）

如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。

```js
"t" && "" // ""
"t" && "f" // "f"
"t" && (1+2) // 3
"" && "f" // ""
"" && "" // ""
```

> 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。

#### 或运算符（||）

如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。

```js
"t" || "" // "t"
"t" || "f" // "t"
"" || "f" // "f"
"" || "" // ""
```

> 或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值。

#### 三元条件运算符（ ? :）

三元条件运算符用问号（？）和冒号（：），分隔三个表达式。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。

```js
"t" ? true : false // true

0 ? true : false // false
```

#### 位运算

> http://javascript.ruanyifeng.com/grammar/operator.html#toc14

#### 圆括号运算符

圆括号是一种运算符，它有两种用法：如果把表达式放在圆括号之中，作用是求值；如果跟在函数的后面，作用是调用函数。

对象放在圆括号之中，则会返回对象的值，即对象本身。

```js
var o = {p:1};

(o)
// Object {p: 1}
```

#### void运算符

void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。

void运算符的优先性很高

```js
<a href="javascript:void(f())">文字</a>

//下面的代码会提交表单，但是不会产生页面跳转。

<a href="javascript:void(document.form.submit())">
文字</a>
```

#### 逗号运算符

逗号运算符用于对两个表达式求值，并返回后一个表达式的值。

```js
"a", "b" // "b"

var x = 0;
var y = (x++, 10);
x // 1
y // 10
```

#### 运算顺序

赋值运算符（=）和三元条件运算符（?:）是少数运算符的计算顺序是从右到左。

```js
w = x = y = z;
q = a ? b : c ? d : e ? f : g;

w = (x = (y = z));
q = a ? b : (c ? d : (e ? f : g));
```

下表按从最高到最低的优先级列出JavaScript运算符。

| 运算符                             | 描述                                         |
| ---------------------------------- | -------------------------------------------- |
| . [] ()                            | 字段访问、数组下标、函数调用以及表达式分组   |
| ++ -- - ~ ! delete new typeof void | 一元运算符、返回数据类型、对象创建、未定义值 |
| * / %                              | 乘法、除法、取模                             |
| + - +                              | 加法、减法、字符串连接                       |
| << >> >>>                          | 移位                                         |
| < <= > >= instanceof               | 小于、小于等于、大于、大于等于、instanceof   |
| == != === !==                      | 等于、不等于、严格相等、非严格相等           |
| &                                  | 按位与                                       |
| ^                                  | 按位异或                                     |
| &#124;                             | 按位或                                       |
| &&                                 | 逻辑与                                       |
| &#124;&#124;                       | 逻辑或                                       |
| ?:                                 | 条件                                         |
| = oP=                              | 赋值、运算赋值                               |
| ,                                  | 多重求值                                     |

[TOC]

# 2016年4月27日

## javascript

### 字符串

读取注释：

```js
(function () { /*
line 1
line 2
line 3
*/}).toString().split('\n').slice(1, -1).join('\n')
// "line 1 line 2 line 3"
```

#### 转义

反斜杠（\\\\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。

- \0 代表没有内容的字符（\u0000）
- \b 后退键（\u0008）
- \f 换页符（\u000C）
- \n 换行符（\u000A）
- \r 回车键（\u000D）
- \t 制表符（\u0009）
- \v 垂直制表符（\u000B）
- \\' 单引号（\u0027）
- \\" 双引号（\u0022）
- \\\\ 反斜杠（\u005C）
- \XXX 用三个八进制数（000到377）表示字符，XXX对应该字符的Unicode，比如\251表示版权符号。
- \xXX 用两个十六进制数（00到FF）表示字符，XX对应该字符的Unicode，比如\xA9表示版权符号。
- \uXXXX 用四位十六进制的Unicode编号代表某个字符，比如\u00A9表示版权符号。

```js
'\251' // "©"
'\xA9' // "©"
'\u00A9' // "©"

'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
```

字符串内部的单个字符无法改变和增删，这些操作会默默地失败。

```js
var s = 'hello';

delete s[0];
s // "hello"

s[1] = 'a';
s // "hello"

s[5] = '!';
s // "hello"
```

length属性返回字符串的长度，该属性也是无法改变的。

```js
var s = 'hello';
s.length // 5

s.length = 3;
s.length // 5
```

#### 字符集

JavaScript使用Unicode字符集，也就是说在JavaScript内部，所有字符都用Unicode表示。

每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为16位长度，即2个字节。

#### Base64转码

Base64是一种编码方法，可以将任意字符转成可打印字符。使用这种编码方法，主要不是为了加密，而是为了不出现特殊字符，简化程序的处理。

JavaScript原生提供两个Base64相关方法。

- btoa()：字符串或二进制值转为Base64编码
- atob()：Base64编码转为原来的编码

> 这两个方法不适合非ASCII码的字符，会报错。 

```js
var string = 'Hello World!';
btoa(string) // "SGVsbG8gV29ybGQh"
atob('SGVsbG8gV29ybGQh') // "Hello World!"
```

要将非ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法。

```js
function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function b64Decode(str) {
  return decodeURIComponent(atob(str));
}

b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"
b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好"
```

**encodeURIComponent() **函数可把字符串作为 URI 组件进行编码。

#### escape,encodeURI,encodeURIComponent

- escape不编码字符有69个：*，+，-，.，/，@，_，0-9，a-z，A-Z
- encodeURI不编码字符有82个：!，#，$，&，'，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z
- encodeURIComponent不编码字符有71个：!， '，(，)，*，-，.，_，~，0-9，a-z，A-Z

**区别：**

- 传递参数时需要使用encodeURIComponent，这样组合的url才不会被#等特殊字符截断。                            

```html
<script language="javascript">document.write('<a href="http://passport.baidu.com/?logout&aid=7&u='+encodeURIComponent ("http://cang.baidu.com/bruce42")+'">退出</a>');
</script>
```

- 进行url跳转时可以整体使用encodeURI

```
Location.href=encodeURI(http://cang.baidu.com/do/s?word=百度&ct=21);

```

- js使用数据时可以使用escape

例如：搜藏中history纪录。

- escape对0-255以外的unicode值进行编码时输出%u****格式，其它情况下escape，encodeURI，encodeURIComponent编码结果相同。

**解码**

- unescape 方法
- decodeURI 方法
- decodeURIComponent 方法

> 资料：http://www.cnblogs.com/jhxk/articles/1634359.html

三个函数主要区别在于不编码字符的不同：

```js
document.write(encodeURIComponent("!#$&'()*+,-./:;=?@_~")+ "<br />")
document.write(escape("!#$&'()*+,-./:;=?@_~")+ "<br />")
document.write(encodeURI("!#$&'()*+,-./:;=?@_~")+ "<br />")

//结果：
//!%23%24%26'()*%2B%2C-.%2F%3A%3B%3D%3F%40_~
//%21%23%24%26%27%28%29*+%2C-./%3A%3B%3D%3F@_%7E
//!#$&'()*+,-./:;=?@_~
```

### 编程风格

**不使用分号的情况**

- for和while循环

```js
for ( ; ; ) {
} // 没有分号

while (true) {
} // 没有分号


do {
  a--;
} while(a > 0); // 分号不能省略
```

- 分支语句：if，switch，try

```js
if (true) {
} // 没有分号

switch () {
} // 没有分号

try {
} catch {
} // 没有分号
```

- 函数的声明语句

```js
function f() {
} // 没有分号


//但是函数表达式仍然要使用分号。
var f = function f() {
};
```

如果本行的结尾或者下一行起首的，是\(、\[、\+、\-、/这五个字符中的一个，分号不会被自动添加。

**变量声明**

为了避免可能出现的问题，最好把变量声明都放在代码块的头部。

```js
for (var i = 0; i < 10; i++) {
  // ...
}

// 写成

var i;
for (i = 0; i < 10; i++) {
  // ...
}
```

**new命令**

JavaScript使用new命令，从构造函数生成一个新对象。

```
var o = new myObject();
```

一旦你忘了加上new，myObject()内部的this关键字就会指向全局对象，导致所有绑定在this上面的变量，都变成全局变量。

**相等和严格相等**

因为”相等”运算符会自动转换变量类型，造成很多意想不到的情况：

```js
0 == ''// true
1 == true // true
2 == true // false
0 == '0' // true
false == 'false' // false
false == '0' // true
’ \t\r\n ' == 0 // true
```

**switch…case结构**

**switch...case**结构要求，在每一个case的最后一行必须是break语句，否则会接着运行下一个case。

switch...case不使用大括号，不利于代码形式的统一。

```js
function doAction(action) {
  switch (action) {
    case 'hack':
      return 'hack';
      break;
    case 'slash':
      return 'slash';
      break;
    case 'run':
      return 'run';
      break;
    default:
      throw new Error('Invalid action.');
  }
}
```

上面的代码建议改写成对象结构。

```js
function doAction(action) {
  var actions = {
    'hack': function () {
      return 'hack';
    },
    'slash': function () {
      return 'slash';
    },
    'run': function () {
      return 'run';
    }
  };

  if (typeof actions[action] !== 'function') {
    throw new Error('Invalid action.');
  }

  return actions[action]();
}

```

[TOC]

# 2016年4月28日

## javascript

### javascript原型与闭包

```js
    function Fn() { }
    Fn.prototype.name = '王福朋';
    Fn.prototype.getYear = function () {
        return 1988;
    };

    var fn = new Fn();
    console.log(fn.name);
    console.log(fn.getYear());
```

> Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。

因为每个对象都有一个隐藏的属性:“**\_\_proto\_\_**”，这个属性引用了创建这个对象的函数的prototype。即：
    

```
fn.__proto__ === Fn.prototype
```

函数与对象之间，不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑。

Object 和 Array 都是函数：

```js
console.log(typeof (Object));  // function
console.log(typeof (Array));  // function ```
```

**每个函数都有一个属性叫做prototype。**

这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/proto.jpg)

> 每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。

> > **Object.prototype是一个特例——它的__proto__指向的是null，切记切记！**

#### Instanceof运算符

Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。

Instanceof的判断队则是：沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/4/img/prototype.png)

#### 继承

访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。

**hasOwnProperty()**对自身的属性会返回true，原型链上的属性会返回false。这个方式是Function.prototype继承自Object.prototype的方法。

### 数组

#### Array对象的静态方法

- isArray方法

Array.isArray方法用来判断一个值是否为数组。

```js
var a = [1, 2, 3];

typeof a // "object"
Array.isArray(a) // true
```

- valueOf方法，toString方法

valueOf方法返回数组本身。

```js
var a = [1, 2, 3];
a.valueOf() // [1, 2, 3]
```

toString 方法返回数组的字符串形式。

```js
var a = [1, 2, 3];
a.toString() // "1,2,3"

var a = [1, 2, 3, [4, 5, 6]];
a.toString() // "1,2,3,4,5,6"
```

- push()，pop()

push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。

```js
var a = [];

a.push(1) // 1
a.push('a') // 2
a.push(true, {}) // 4
a // [1, 'a', true, {}]
```

pop方法用于删除数组的最后一个元素，并返回该元素。

```js
var a = ['a', 'b', 'c'];

a.pop() // 'c'
a // ['a', 'b']

[].pop() // undefined
```

- join()，concat()

join方法以参数作为分隔符，将所有数组成员组成一个字符串返回。

```js
var a = [1, 2, 3, 4];

a.join(' ') // '1 2 3 4'
a.join(' | ') // "1 | 2 | 3 | 4"
a.join() // "1,2,3,4"
```

[TOC]

# 2016年4月29日

## 移动端开发

CSS像素是一个抽象的单位，主要使用在浏览器上，用来精确的度量（确定）Web页面上的内容。一般情况下，CSS像素被称为与设备无关的像素（**device-independent**像素），简称为“**DIPs**”。在一个标准的显示密度下，一个CSS像素对应着一个设备像素。

在javascript中，**“window.devicePixelRatio**”可以用来获得相同的比率。

**window.devicePixelRatio**是设备上物理像素和设备像素（device-independent pixels (dips)）的比例。他有一个计算公式：window.devicePixelRatio = 物理像素/dips。

dips可以用来区分视网膜设备还是非视网膜设备。

> http://www.w3cplus.com/css/towards-retina-web.html

### Emulation 模拟器

1. Device 设备设置
   - model 模型选择
   - resolution 分辨率设置
   - Device pixel ratio 像素比设置

### viewport

```
<meta name="viewport" content="" />
```

1. width [pixel_value | device-width]
2. user-scalable 是否允许缩放 （no||yes）
3. initial-scale 初始比例
4. minimum-scale 允许缩放的最小比例
5. maximum-scale 允许缩放的最大比例 
6. target-densitydpi [dpi_value | device-dpi | high-dpi | medium-dpi | low-dpi] ---安卓系统开始放弃此属性。

### 媒体查询

引入方式：

一、

```
<link rel="stylesheet" type="text/css" href="index.css" media="all and (min-width: 600px)">
```

二、

```
@import url("css/reset.css") all and (min-width: 600px) ;
```

使用@import的话，你必须时刻记得要将@import放到样式代码的最前面，否则它将会不起作用。避免使用@import 同样对网站性能有益。

三、

```js
@media all and (min-width: 600px)
{
    .box
    {
        width:100px;
    }
}
```

#### 媒体类型

1. all 所有媒体
2. braille 盲文触觉设备
3. embossed 盲文打印机
4. print 手持设备 
5. projection 打印预览
6. screen 彩屏设备
7. speech '听觉'类似的媒体类型
8. tty 不适用像素的设备
9. tv  电视

#### 媒体特性

1. (max-width:599px) 
2. (min-width:600px) 
3. (orientation:portrait) 竖屏
4. (orientation:landscape)        横屏
5. (-webkit-min-device-pixel-ratio: 2) 像素比

#### 关键字

1. and
2. not      not关键字是用来排除某种制定的媒体类型
3. only     only用来定某种特定的媒体类型