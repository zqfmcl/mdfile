---
title: Java题解枚举
date: 2019-10-06 10:00:00
tags: 题解
       
---

## 第十九章 枚举

public class TrafficLight1 {

​       Signal color = RED;

​       public void change() {

​              switch(color) {

​                     case RED:       color = GREEN;

​                                   break;

​                     case GREEN:  color = YELLOW;

​                                   break;

​                     case YELLOW:       color = RED;

​                                   break;                   

​              }

​       }

​       public String toString() {

​              return "The traffic light is " + color;

​       }

​       public static void main(String[] args) {

​              TrafficLight1 t = new TrafficLight1();

​              for(int i = 0; i < 7; i++) {

​                     print(t);

​                     t.change();

​              }             

​       }

}

enum CartoonCharacter { 

​       SLAPPY, SPANKY, PUNCHY, SILLY, BOUNCY, NUTTY, BOB;

​       private static Random rand = new Random();

​       public static CartoonCharacter next() {

​              return values()[rand.nextInt(values().length)];

​       }

}

 

public class EnumImplementation2 {

​       public static void main(String[] args) {

​                           CartoonCharacter cc = CartoonCharacter.BOB;

​              for(int i = 0; i < 10; i++) {

​                     System.out.print(cc.next()); 

​                     System.out.print((i < 9) ? ", " : "");                     

​              }

​       }

}      

enum Course3 {

​       APPETIZER(Food3.Appetizer.class),

​       MAINCOURSE(Food3.MainCourse.class),

​       SECONDCOURSE(Food3.SecondCourse.class),       DESSERT(Food3.Dessert.class),

​       COFFEE(Food3.Coffee.class);

​       private Food3[] values;

​       private Course3(Class<? extends Food3> kind) {

​              values = kind.getEnumConstants();

​       }

​       public Food3 randomSelection() {

​              return Enums.random(values);

​       }

}

 

interface Food3 {

​       enum Appetizer implements Food3 {

​              SALAD, SOUP, SPRING_ROLLS;

​       }

​       enum MainCourse implements Food3 {

​              LASAGNE, BURRITO, PAD_THAI,

​              LENTILS, HUMMOUS, VINDALOO;

​       }

​       enum SecondCourse implements Food3 {

​              LEG_OF_LAMB, NEW_YORK_STEAK, 

​              MAINE_LOBSTER, ALASKAN_KING_CRAB;

​       }

​       enum Dessert implements Food3 {

​              TIRAMISU, GELATO, BLACK_FOREST_CAKE,

​              FRUIT, CREME_CARAMEL;

​       }

​       enum Coffee implements Food3 {

​              BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,

​              LATTE, CAPPUCCINO, TEA, HERB_TEA;

​       }

}

 

public class Meal3 {

​       public static void main(String[] args) {

​              for(int i = 0; i < 5; i++) {

​                     for(Course3 course : Course3.values()) {

​                            Food3 food = course.randomSelection();

​                            System.out.println(food);

​                     }

​                     System.out.println("---");

​              }

​       }

public enum Meal4 {

​       APPETIZER(Food.Appetizer.class),

​       MAINCOURSE(Food.MainCourse.class),

​       SECONDCOURSE(Food.SecondCourse.class),         DESSERT(Food.Dessert.class),

​       COFFEE(Food.Coffee.class);

​       private Food[] values;

​       private Meal4(Class<? extends Food> kind) {

​              values = kind.getEnumConstants();

​       }

​       public interface Food {

​             enum Appetizer implements Food {

​                     SALAD, SOUP, SPRING_ROLLS;

​                     }

​              enum MainCourse implements Food {

​                     LASAGNE, BURRITO, PAD_THAI,

​                     LENTILS, HUMMOUS, VINDALOO;

​              }

​              enum SecondCourse implements Food {

​                     LEG_OF_LAMB, NEW_YORK_STEAK, 

​                     MAINE_LOBSTER, ALASKAN_KING_CRAB;

​              }

​              enum Dessert implements Food {

​                     TIRAMISU, GELATO, BLACK_FOREST_CAKE,

​                     FRUIT, CREME_CARAMEL;

​              }

​              enum Coffee implements Food {

​                     BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,

​                     LATTE, CAPPUCCINO, TEA, HERB_TEA;

​              }

​       }

​       public Food randomSelection() {

​              return Enums.random(values);

​       }

​       public static void main(String[] args) {

​              for(int i = 0; i < 5; i++) {

​                     for(Meal4 meal: Meal4.values()) {

​                            Food food = meal.randomSelection();

​                            System.out.println(food);

​                     }

​                     System.out.println("---");

​              }

​       }

}

 

public enum VowelsAndConsonants5 {

​       VOWEL('a', 'e', 'i', 'o', 'u'),

​       SOMETIMES_A_VOWEL('w', 'y'),

​       CONSONANT('b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm',

​              'n', 'p', 'q', 'r', 's', 't', 'v', 'x', 'z');

​       private Character[] letters;

​       private VowelsAndConsonants5(Character... letters) {

​              this.letters = letters;

​       }

​       public static VowelsAndConsonants5 LetterType(Character c) {

​              if(Arrays.asList(VOWEL.letters).contains(c)) return VOWEL;

​              if(Arrays.asList(SOMETIMES_A_VOWEL.letters).contains(c)) 

​                     return SOMETIMES_A_VOWEL;

​              return CONSONANT;

​       }

​       public static void main(String[] args) {

​              Random rand = new Random();

​              for(int i = 0; i < 100; i++) {

​                     int c = rand.nextInt(26) + 'a';

​                     printnb((char)c + ", " + c + ": "); 

​                     print(LetterType((char)c));                   

​              }             

​       }

}

interface Food {}

 

enum Appetizer implements Food {

​       SALAD, SOUP, SPRING_ROLLS;

​       }

enum MainCourse implements Food {

​       LASAGNE, BURRITO, PAD_THAI,

​       LENTILS, HUMMOUS, VINDALOO;

}

enum Dessert implements Food {

​       TIRAMISU, GELATO, BLACK_FOREST_CAKE,

​       FRUIT, CREME_CARAMEL;

}

enum Coffee implements Food {

​       BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,

​       LATTE, CAPPUCCINO, TEA, HERB_TEA;

}

 

public enum Meal6 {

​       APPETIZER(Appetizer.class),

​       MAINCOURSE(MainCourse.class),

​       DESSERT(Dessert.class),

​       COFFEE(Coffee.class);

​       private Food[] values;

​       private Meal6(Class<? extends Food> kind) {

​              values = kind.getEnumConstants();

​       }      

​       public Food randomSelection() {

​              return Enums.random(values);

​       }

​       public static void main(String[] args) {

​              for(int i = 0; i < 5; i++) {

​                     for(Meal6 meal: Meal6.values()) {

​                            Food food = meal.randomSelection();

​                            System.out.println(food);

​                     }

​                     System.out.println("---");

​              }

​       }

}

 

 

 

 

  

Source code is in the src.zip file in the downloadable JDK, e.g., C:\jdk1.6.0\src.zip.

EnumSet.java file is in folder C:\jdk1.6.0\src\java\util. Open with a web browser or WordPad.

 

Package & import:

package java.util;

import sun.misc.SharedSecrets;

 

EnumSet is specialized Set for enums: 

public abstract class EnumSet<E extends Enum<E>> extends AbstractSet<E>

​    implements Cloneable, java.io.Serializable

 

Fields:

final Class<E> elementType;  final Enum[] universe;

private static Enum[] ZERO_LENGTH_ENUM_ARRAY = new Enum[0];

 

Constructor:

EnumSet(Class<E>elementType, Enum[] universe) {

​        this.elementType = elementType;

​        this.universe    = universe;

​    }

 

Methods:

public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {

​        Enum[] universe = getUniverse(elementType);

​        if (universe == null)

​            throw new ClassCastException(elementType + " not an enum");

​        if (universe.length <= 64)

​            return new RegularEnumSet<E>(elementType, universe);

​        else

​            return new JumboEnumSet<E>(elementType, universe);

​    }

public static <E extends Enum<E>> EnumSet<E> allOf(Class<E> elementType) {

​        EnumSet<E> result = noneOf(elementType);

​        result.addAll();

​        return result;

​    }

abstract void addAll();

public static <E extends Enum<E>> EnumSet<E> copyOf(EnumSet<E> s) {

​        return s.clone();

​    }

public static <E extends Enum<E>> EnumSet<E> copyOf(Collection<E> c) {

​        if (c instanceof EnumSet) {

​            return ((EnumSet<E>)c).clone();

​        } else {

​            if (c.isEmpty())

​                throw new IllegalArgumentException("Collection is empty");

​            Iterator<E> i = c.iterator();

​            E first = i.next();

​            EnumSet<E> result = EnumSet.of(first);

​            while (i.hasNext())

​                result.add(i.next());

​            return result;

​        }

​    }

public static <E extends Enum<E>> EnumSet<E> complementOf(EnumSet<E> s) {

​        EnumSet<E> result = copyOf(s);

​        result.complement();

​        return result;

​    }

public static <E extends Enum<E>> EnumSet<E> of(E e) {

​        EnumSet<E> result = noneOf(e.getDeclaringClass());

​        result.add(e);

​        return result;

​    }

public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2) {

​        EnumSet<E> result = noneOf(e1.getDeclaringClass());

​        result.add(e1);

​        result.add(e2);

​        return result;

​    }

public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3) {

​        EnumSet<E> result = noneOf(e1.getDeclaringClass());

​        result.add(e1);

​        result.add(e2);

​        result.add(e3);

​        return result;

​    }

public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3, E e4) {

​        EnumSet<E> result = noneOf(e1.getDeclaringClass());

​        result.add(e1);

​        result.add(e2);

​        result.add(e3);

​        result.add(e4);

​        return result;

​    }

public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3, E e4,

​                                                    E e5)

​    {

​        EnumSet<E> result = noneOf(e1.getDeclaringClass());

​        result.add(e1);

​        result.add(e2);

​        result.add(e3);

​        result.add(e4);

​        result.add(e5);

​        return result;

​    }

public static <E extends Enum<E>> EnumSet<E> of(E first, E... rest) {

​        EnumSet<E> result = noneOf(first.getDeclaringClass());

​        result.add(first);

​        for (E e : rest)

​            result.add(e);

​        return result;

​    }

public static <E extends Enum<E>> EnumSet<E> range(E from, E to) {

​        if (from.compareTo(to) > 0)

​            throw new IllegalArgumentException(from + " > " + to);

​        EnumSet<E> result = noneOf(from.getDeclaringClass());

​        result.addRange(from, to);

​        return result;

​    }

abstract void addRange(E from, E to);

public EnumSet<E> clone() {

​        try {

​            return (EnumSet<E>) super.clone();

​        } catch(CloneNotSupportedException e) {

​            throw new AssertionError(e);

​        }

​    }

abstract void complement();

 final void typeCheck(E e) {

​        Class eClass = e.getClass();

​        if (eClass != elementType && eClass.getSuperclass() != elementType)

​            throw new ClassCastException(eClass + " != " + elementType);

​    }

private static <E extends Enum<E>> E[] getUniverse(Class<E> elementType) {

​        return SharedSecrets.getJavaLangAccess()

​                                   .getEnumConstantsShared(elementType);

​    }

 

For serialization:

Class used to serialize EnumSet instances:

private static class SerializationProxy <E extends Enum<E>>

​        implements java.io.Serializable {

​       private final Class<E> elementType;

​       private final Enum[] elements;

​       SerializationProxy(EnumSet<E> set) {

​            elementType = set.elementType;

​            elements = (Enum[]) set.toArray(ZERO_LENGTH_ENUM_ARRAY);

​        }

​       private Object readResolve() {

​            EnumSet<E> result = EnumSet.noneOf(elementType);

​            for (Enum e : elements)

​                result.add((E)e);

​            return result;

​        }

​        private static final long serialVersionUID = 362491234563181265L;

}

Object writeReplace() {

​        return new SerializationProxy<E>(this);

​    }

 

class Mail {

​             enum GeneralDelivery { YES, NO1, NO2, NO3, NO4, NO5 }

​       enum Scannability { UNSCANNABLE, YES1, YES2, }

​       enum Readability { ILLEGIBLE, YES1, YES2, YES3, YES4 }

​       enum ForwardAddress { YES, NO1, NO2, NO3, NO4, NO5 }

​       enum Address { INCORRECT, OK1, OK2, OK3, OK4, OK5 }

​       enum ReturnAddress { MISSING, OK1, OK2, OK3, OK4, OK5 }

​       GeneralDelivery generalDelivery;

​       Scannability scannability;

​       Readability readability;

​       ForwardAddress forwardAddress;

​       Address address;

​       ReturnAddress returnAddress;

​       static long counter = 0;

​       long id = counter++;

​       public String toString() { return "Mail " + id; }

​       public String details() {

​              return toString() +

​                     ", General Delivery: " + generalDelivery +

​                     ", Address Scannability: " + scannability + 

​                     ", Address Readability: " + readability + 

​                     ", ForwardAddress: " + forwardAddress + 

​                     ", Address Address: " + address +

​                     ", Return address: " + returnAddress;

​       } 

​             public static Mail randomMail() {

​              Mail m = new Mail();

​              m.generalDelivery = Enums.random(GeneralDelivery.class);

​              m.scannability = Enums.random(Scannability.class);

​              m.readability = Enums.random(Readability.class);

​              m.forwardAddress = Enums.random(ForwardAddress.class);

​              m.address = Enums.random(Address.class);

​              m.returnAddress = Enums.random(ReturnAddress.class);      

​              return m;

​       }

​       public static Iterable<Mail> generator(final int count) {

​              return new Iterable<Mail>() {

​                     int n = count;

​                     public Iterator<Mail> iterator() {

​                            return new Iterator<Mail>() {

​                                   public boolean hasNext() { return n-- > 0; }

​                                   public Mail next() { return randomMail(); }

​                                   public void remove() {                                           throw new UnsupportedOperationException();

​                                   }      

​                            };

​                     }

​              };

​       }

}

 

public class PostOffice8 {

​       enum MailHandler {

​              GENERAL_DELIVERY {

​                     boolean handle(Mail m) {

​                            switch(m.generalDelivery) {

​                                   case YES:

​                                          print("Using general delivery for " + m);

​                                          return true;

​                                   default: return false;

​                            }

​                     }

​              },

​              MACHINE_SCAN {

​                     boolean handle(Mail m) {

​                            switch(m.scannability) {

​                                   case UNSCANNABLE: return false;

​                                   default:

​                                          switch(m.forwardAddress) {

​                                                 case YES: 

​                                                        print("Forwarding " + m + " automatically");

​                                                        return true;

​                                                 default: 

​                                                        switch(m.address) {

​                                                               case INCORRECT: return false;

​                                                               default:

​                                                                      print("Delivering " + m + " automatically");

​                                                                      return true;

​                                                        }

​                                          }                                         

 

 

​                            }

​                     }

​              },

​              FORWARDING {

​                     boolean handle(Mail m) {

​                            switch(m.forwardAddress) {

​                                   case YES: 

​                                          print("Forwarding " + m);

​                                          return true;

​                                   default: return false;

​                                          

​                            }

​                     }

​              },

​              VISUAL_INSPECTION {

​                     boolean handle(Mail m) {

​                            switch(m.readability) {

​                                   case ILLEGIBLE: return false;

​                                   default:

​                                          switch(m.address) {

​                                                 case INCORRECT: return false;

​                                                 default:

​                                                        print("Delivering " + m + " normally");

​                                                        return true;

​                                          }

​                            }

​                     }

​              },

​              RETURN_TO_SENDER {

​                     boolean handle(Mail m) {

​                            switch(m.returnAddress) {

​                                   case MISSING: return false;

​                                   default:

​                                          print("Return " + m + " to sender");

​                                          return true;

​                            }

​                     }

​              };

​              abstract boolean handle(Mail m);

​       }

​       static void handle(Mail m) {

​              for(MailHandler handler : MailHandler.values())

​                     if(handler.handle(m)) return;

​                     print(m + " is a dead letter");

​       }

​       public static void main(String[] args) {

​              for(Mail mail : Mail.generator(20)) {

​                     print(mail.details());

​                     handle(mail);

​                     print("*****");

​              }

​       }

}

class Mail {

​             enum GeneralDelivery { YES, NO1, NO2, NO3, NO4, NO5 }

​       enum Scannability { UNSCANNABLE, YES1, YES2, YES3, YES4 }

​       enum Readability { ILLEGIBLE, YES1, YES2, YES3, YES4 }

​       enum Address { INCORRECT, OK1, OK2, OK3, OK4, OK5, OK6 }

​       enum ReturnAddress { MISSING, OK1, OK2, OK3, OK4, OK5 }

​       GeneralDelivery generalDelivery;

​       Scannability scannability;

​       Readability readability;

​       Address address;

​       ReturnAddress returnAddress;

​       static long counter = 0;

​       long id = counter++;

​       public String toString() { return "Mail " + id; }

​       public String details() {

​              return toString() +

​                     ", General Delivery: " + generalDelivery +

​                     ", Address Scannability: " + scannability + 

​                     ", Address Readability: " + readability + 

​                     ", Address Address: " + address +

​                     ", Return address: " + returnAddress;

​       } 

​             public static Mail randomMail() {

​              Mail m = new Mail();

​              m.generalDelivery = Enums.random(GeneralDelivery.class);

​              m.scannability = Enums.random(Scannability.class);

​              m.readability = Enums.random(Readability.class);

​              m.address = Enums.random(Address.class);

​              m.returnAddress = Enums.random(ReturnAddress.class);      

​              return m;

​       }

​       public static Iterable<Mail> generator(final int count) {

​              return new Iterable<Mail>() {

​                     int n = count;

​                     public Iterator<Mail> iterator() {

​                            return new Iterator<Mail>() {

​                                   public boolean hasNext() { return n-- > 0; }

​                                   public Mail next() { return randomMail(); }

​                                   public void remove() {                                           throw new UnsupportedOperationException();

​                                   }      

​                            };

​                     }

​              };

​       }

}

 

interface Handler { abstract boolean handle(Mail m); }  

public class PostOffice9 {

​       enum MailHandler { GENERAL_DELIVERY, MACHINE_SCAN, VISUAL_INSPECTION, RETURN_TO_SENDER }

​       public static void handle(Mail m, EnumMap<MailHandler,Handler> em) {   

​              for(Map.Entry<MailHandler,Handler> e : em.entrySet()) {

​                     if(e.getValue().handle(m)) return;                                                 

​              }

​              print(m + " is a dead letter");              

​       }      

​       public static void main(String[] args) {

​              EnumMap<MailHandler,Handler> em = new EnumMap<MailHandler,Handler>(MailHandler.class);

​              em.put(MailHandler.GENERAL_DELIVERY, new Handler() {

​                     public boolean handle(Mail m) {

​                            switch(m.generalDelivery) {

​                                   case YES:

​                                          print("Using general delivery for " + m);

​                                          return true;

​                                   default: return false;

​                            }

​                     }

​              });

​              em.put(MailHandler.MACHINE_SCAN, new Handler() {

​                     public boolean handle(Mail m) {

​                            switch(m.scannability) {

​                                   case UNSCANNABLE: return false;

​                                   default:

​                                          switch(m.address) {

​                                                 case INCORRECT: return false;

​                                                 default:

​                                                        print("Delivering " + m + " automatically");

​                                                        return true;

​                                          }

​                            }

​                     }      

​              });

​              em.put(MailHandler.VISUAL_INSPECTION, new Handler() {

​                     public boolean handle(Mail m) {

​                            switch(m.readability) {

​                                   case ILLEGIBLE: return false;

​                                   default:

​                                          switch(m.address) {

​                                                 case INCORRECT: return false;

​                                                 default:

​                                                        print("Delivering " + m + " normally");

​                                                        return true;

​                                          }

​                            }

​                     }

​              });

​              em.put(MailHandler.RETURN_TO_SENDER, new Handler() {

​                     public boolean handle(Mail m) {

​                            switch(m.returnAddress) {

​                                   case MISSING: return false;

​                                   default:

​                                          print("Return " + m + " to sender");

​                                          return true;

​                            }

​                     }

​              });

​              for(Mail mail : Mail.generator(10)) {

​                     print(mail.details());

​                     handle(mail, em);

​                     print("*****"); 

​              }

​       }

}

enum Category {

​       MONEY(NICKEL, DIME, QUARTER, DOLLAR),

​       ITEM_SELECTION(TOOTHPASTE, CHIPS, SODA, SOAP),

​       QUIT_TRANSACTION(ABORT_TRANSACTION),

​       SHUT_DOWN(STOP);

​       private Input[] values;

​       Category(Input... types) { values = types; }

​       private static EnumMap<Input,Category> categories =

​              new EnumMap<Input,Category>(Input.class);

​       static {

​              for(Category c : Category.class.getEnumConstants())

​                     for(Input type : c.values)

​                            categories.put(type, c);

​       }      

​       public static Category categorize(Input input) {

​              return categories.get(input);

​       }

}

 

interface Command {        void next(Input input);

​       void next();

}

 

enum State {

​       RESTING,

​       ADDING_MONEY,

​       DISPENSING,

​       GIVING_CHANGE, 

​       TERMINAL

}

 

class VendingMachine10 {

​       int id = ++count;

​       static int count = 0; 

​       State state = State.RESTING;

​       int amount = 0;   int banked = 0;    Input input = null;

​       Input selection = null;

​       boolean isTransient = false;

​             class RestingDo implements Command {

​              public void next(Input in) {

​                     isTransient = false;

​                     input = in;

​                     switch(Category.categorize(in)) {

​                            case MONEY:

​                                   amount += in.amount();

​                                   state = State.ADDING_MONEY;

​                                   break;

​                            case SHUT_DOWN:

​                                   state = State.TERMINAL;

​                            default:                               

​                     }

​              }

​              public void next() { 

​                     isTransient = false;                     

​              }

​       }

​       class AddingMoneyDo implements Command {

​              public void next(Input input) {

​                     isTransient = false;

​                     switch(Category.categorize(input)) {

​                            case MONEY:

​                                   amount += input.amount();

​                                   break;

​                            case ITEM_SELECTION:

​                                   selection = input;

​                                   if(amount < selection.amount()) {

​                                          print("Insufficient money for " + selection);                                                 }

​                                   else {

​                                          state = State.DISPENSING;

​                                          isTransient = true;

​                                   }

​                                   break;

​                            case QUIT_TRANSACTION:

​                                   state = State.GIVING_CHANGE;

​                                   isTransient = true;

​                                   break;

​                            case SHUT_DOWN:

​                                   state = State.TERMINAL;

​                                   banked = banked += amount;                               

​                            default:

​                     }

​              }

​              public void next() { isTransient = false; }

​       }

​       class DispensingDo implements Command {

​              public void next() {

​                     isTransient = true; 

​                     print("Here is your " + selection);

​                     state = State.GIVING_CHANGE;

​              }

​              public void next(Input input) { 

​                     isTransient = true; 

​                     print("Here is your " + selection);

​                     state = State.GIVING_CHANGE;  

​              }

​       }

​       class GivingChangeDo implements Command {

​              public void next(Input input) { 

​                     isTransient = true; 

​                     if(amount > selection.amount()) {

​                            print("Your change: " + (amount - selection.amount()));                              

​                     }

​                     banked = banked += selection.amount();

​                     amount = 0;                      state = State.RESTING;                               

​              }

​              public void next() {

​                     isTransient = true; 

​                     if(amount < selection.amount())

​                            print("Returning your: " + amount); 

​                     if(amount > selection.amount()) {

​                            print("Your change: " + (amount - selection.amount()));

​                            banked = banked += selection.amount();                              

​                     }

​                     if(amount == selection.amount())

​                            banked = banked += selection.amount();

​                     amount = 0;

​                     state = State.RESTING;

​              }

​       }

​       class TerminalDo implements Command { 

​              public void next(Input input) {

​                     print("state TERMINAL");

​                     isTransient = false;

​              }

​              public void next() {

​                     print("state TERMINAL");

​                     isTransient = false;              

​              }             

​       }

​       Map<State,Command> em = 

​              Collections.synchronizedMap(new EnumMap<State,Command>(State.class));

​       VendingMachine10() {              print("VendingMachine10()#" + id);   

​              em.put(State.RESTING, new RestingDo());

​              em.put(State.ADDING_MONEY, new AddingMoneyDo());

​              em.put(State.DISPENSING, new DispensingDo());

​              em.put(State.GIVING_CHANGE, new GivingChangeDo());

​              em.put(State.TERMINAL, new TerminalDo());

​       }

​       void showAmount() { print("amount = " + amount); }

​       void showBanked() { print("banked = " + banked); }

​       public static void main(String[] args) {       

​              Generator<Input> gen = new RandomInputGenerator();

​              if(args.length == 1)

​                     gen = new FileInputGenerator10(args[0]);

​              VendingMachine10 vm10a = new VendingMachine10();

​              VendingMachine10 vm10b = new VendingMachine10(); 

​              VendingMachine10 vm10c = new VendingMachine10();

​              print();

​              print("Testing VendingMachine 10a:");

​              while(vm10a.state != State.TERMINAL) {

​                     Input in = gen.next();

​                     (vm10a.em.get(vm10a.state)).next(in);

​                     while(vm10a.isTransient) {

​                            (vm10a.em.get(vm10a.state)).next();                         

​                     }      

​                     vm10a.showAmount();                                           

​              }

​              vm10a.showBanked();

​              print();

​              print("Testing VendingMachine 10b:");

​              gen = new FileInputGenerator10("VendingMachine10bInput.txt");

​              while(vm10b.state != State.TERMINAL) {

​                     Input in = gen.next();

​                     (vm10b.em.get(vm10b.state)).next(in);

​                     while(vm10b.isTransient) {

​                            (vm10b.em.get(vm10b.state)).next();                        

​                     }      

​                     vm10b.showAmount();                                           

​              }

​              print();

​              print("Testing VendingMachine 10c:");

​              gen = new FileInputGenerator10("VendingMachine10cInput.txt");

​              while(vm10c.state != State.TERMINAL) {

​                     Input in = gen.next();

​                     (vm10c.em.get(vm10c.state)).next(in);

​                     while(vm10c.isTransient) {

​                            (vm10c.em.get(vm10c.state)).next();                         

​                     }      

​                     vm10c.showAmount();                                            

​              }

​       }

}

 

 class FileInputGenerator10 implements Generator<Input> {

​       private Iterator<String> input;

​       public FileInputGenerator10(String fileName) {

​              input = new TextFile(fileName, ";").iterator();

​       }

​       public Input next() {

​              if(input.hasNext()) {

​                     return Enum.valueOf(Input.class, input.next().trim());

​              }

​              return null;

​       }      

}

 

 interface VendingInput { String name(); } 

 

class MonetaryUnit implements VendingInput {

​       private String name;

​       private int amount = 0;

​       MonetaryUnit(String name, int amount) {

​              this.name = name;

​              this.amount = amount;

​       }

​       public String name() { return name; }

​       public int amount() { return amount; }

}

 

class VendedItem implements VendingInput {

​       private String name;

​       private int price = 0;

​       VendedItem(String name, int price) {

​              this.name = name;

​              this.price = price;

​       }

​       public String name() { return name; }

​       public int price() { return price; }

} 

 

class VendingEvent implements VendingInput {

​       private String name;

​       VendingEvent(String name) {

​              this.name = name;

​       }

​       public String name() { return name; }  

}

 

public class VendingMachine11 {

​       private static State state = State.RESTING;

​       private static int amount = 0;

​       private static VendedItem selection = null;

​       enum StateDuration { TRANSIENT }         enum State {

​              RESTING {

​                     void next(VendingInput in) {

​                            if(MonetaryUnit.class.isInstance(in)) {

​                                   amount += ((MonetaryUnit)in).amount();

​                                   state = ADDING_MONEY;   

​                            }

​                            if(VendingEvent.class.isInstance(in)) {

​                                   if(((VendingEvent)in).name().equals("Stop"))

​                                          state = TERMINAL;

​                            }

​                     }

​              },

​              ADDING_MONEY {

​                     void next(VendingInput in) {

​                            if(MonetaryUnit.class.isInstance(in)) {

​                                   amount += ((MonetaryUnit)in).amount();

​                            }                           

​                            if(VendedItem.class.isInstance(in)) {

​                                   selection = (VendedItem)in;

​                                   if(amount < selection.price())

​                                          print("Insufficient money for " + selection.name());

​                                   else state = DISPENSING;

​                            }

​                            if(VendingEvent.class.isInstance(in)) {

​                                   if(((VendingEvent)in).name().equals("AbortTransaction"))

​                                          state = GIVING_CHANGE;

​                                   if(((VendingEvent)in).name().equals("Stop"))

​                                          state = TERMINAL;

​                            }                           

​                     }

​              },

​              DISPENSING(StateDuration.TRANSIENT) {

​                     void next() {

​                            print("here is your " + selection.name());

​                            amount -= selection.price();

​                            state = GIVING_CHANGE;

​                     }

​              },

​              GIVING_CHANGE(StateDuration.TRANSIENT) {

​                     void next() {

​                            if(amount > 0) {

​                                   print("Your change: " + amount);

​                                   amount = 0;

​                            }

​                            state = RESTING;

​                     }

​              },

​              TERMINAL { void output() { print("Halted"); } };

​              private boolean isTransient = false;

​              State()     {}           State(StateDuration trans) { isTransient = true; }

​              void next(VendingInput in) {

​                     throw new RuntimeException("Only call " +

​                            "next(VendingInput in) for non-transient states");

​              }

​              void next() {   

​                     throw new RuntimeException("Only call next() for " +

​                            "StateDuration.TRANSIENT states");

​              }

​              void output() { print(amount); }

​       }

​       static void run(Generator<VendingInput> gen) {

​              while(state != State.TERMINAL) {        

​                     state.next(((FileInputGenerator11)gen).next());

​                     while(state.isTransient) 

​                            state.next();

​                     state.output();                             

​              }

​              state = State.RESTING;

​              print();

​       }

​       static void runRandom(Generator<VendingInput> gen) {

​              while(state != State.TERMINAL) {        

​                     state.next(((FileInputGenerator11)gen).randomNext());

​                     while(state.isTransient) 

​                            state.next();

​                     state.output();                             

​              }

​              state = State.RESTING;

​              print();                         

​       }

​       static void runTextExample(Generator<VendingInput> gen) {

​              while(state != State.TERMINAL) { 

​                                  state.next(((FileInputGenerator11)gen).textExampleNext("VendingMachineInput.txt"));

​                     while(state.isTransient) 

​                            state.next();

​                     state.output();                             

​              }

​              state = State.RESTING;

​              print();                         

​       }

​       public static void main(String[] args) {

​              FileInputGenerator11 gen = 

​                     new FileInputGenerator11("VendingMachine11Input.txt");

​              runRandom(gen);              run(gen); 

​              runTextExample(gen);        }      

}

 

class FileInputGenerator11 implements Generator<VendingInput> {

​       private ArrayList<String> list;

​       private List<VendingInput> vendList = new ArrayList<VendingInput>();

​       private Iterator<VendingInput> it;

​       private Random rand = new Random();

​       private Iterator<String> input = new TextFile("VendingMachineInput.txt", ";").iterator();

​             public FileInputGenerator11(String fileName) { 

​              list = new TextFile(fileName, ",|;|:");

​              int m = list.indexOf("Money");

​              int se = list.indexOf("Selection");

​              int e = list.indexOf("VendingEvent");

​              VendingInput vIn;

​              for(String s : list) {

​                            int x = list.indexOf(s);

​                            if(m < x && x < se) {

​                                   String[] sa = s.split("\\(|\\)");

​                                   vIn = new MonetaryUnit(sa[0], Integer.parseInt(sa[1]));

​                                   vendList.add(vIn);

​                            }

​                            else if(se < x && x < e) {

​                                   String[] sa = s.split("\\(|\\)");

​                                   vIn = new VendedItem(sa[0], Integer.parseInt(sa[1]));

​                                   vendList.add(vIn);

​                            }

​                            else if(e < x) {

​                                   vIn = new VendingEvent(s);

​                                   vendList.add(vIn);

​                            }                    

​              }

​              it = vendList.iterator();         

​       }

​       public VendingInput next() {

​              if(list.isEmpty()) return null;         

​              if(it.hasNext()) {

​                     return it.next();                     

​              }

​              return null;

​       }

​       public VendingInput randomNext() { 

​              return vendList.get(rand.nextInt(vendList.size()));

​       }

​       public VendingInput textExampleNext(String fileName) {              

​              if(!input.hasNext()) return null;

​              String s = input.next().trim();

​              String s1 = s.charAt(0) + s.substring(1).toLowerCase();

​              for(int i = 0; i < this.vendList.size(); i++) {

​                     if(vendList.get(i).name().equals(s1)) { 

​                            return vendList.get(i);                  

​                     }

​              }

​              return null;

​       }      

}