---
title: Java题解并发
date: 2019-10-06 10:00:00
tags: 题解
 
---

## 第二十一章 并发

class Ex1RunnerA implements Runnable {

​       public Ex1RunnerA() {

​              System.out.println("Constructing Ex1RunnerA");

​       }

​       public void run() {

​              for(int i = 0; i < 3; i++) {

​                     System.out.println("Hi from Ex1RunnerA");       

​                     Thread.yield();

​              }

​              System.out.println("Ex1RunnerA task complete.");

​              return;                         

​       }

}

 

class Ex1RunnerB implements Runnable {

​       public Ex1RunnerB() {

​              System.out.println("Constructing Ex1RunnerB");

​       }

​       public void run() {

​              for(int i = 0; i < 3; i++) {

​                     System.out.println("Hi from Ex1RunnerB");       

​                     Thread.yield();

​              }

​              System.out.println("Ex1RunnerB task complete.");

​              return;

​       }

}

 

class Ex1RunnerC implements Runnable {

​       public Ex1RunnerC() {

​              System.out.println("Constructing Ex1RunnerC");

​       }

​       public void run() {

​              for(int i = 0; i < 3; i++) {

​                     System.out.println("Hi from Ex1RunnerC");       

​                     Thread.yield();

​              }

​              System.out.println("Ex1RunnerC task complete.");

​              return;    

​       }

}

 

public class Ex1 {

​       public static void main(String[] args) {

​              Thread ta = new Thread(new Ex1RunnerA());           

​              Thread tb = new Thread(new Ex1RunnerB());           

​              Thread tc = new Thread(new Ex1RunnerC());

​              ta.start();

​              tb.start();

​              tc.start();

​       }

}      

class Ex1RunnerA implements Runnable {

​       public Ex1RunnerA() {

​              System.out.println("Constructing Ex1RunnerA");

​       }

​       public void run() {

​              for(int i = 0; i < 3; i++) {

​                     System.out.println("Hi from Ex1RunnerA");       

​                     Thread.yield();

​              }

​              System.out.println("Ex1RunnerA task complete.");

​              return;                         

​       }

}

 

class Ex1RunnerB implements Runnable {

​       public Ex1RunnerB() {

​              System.out.println("Constructing Ex1RunnerB");

​       }

​       public void run() {

​              for(int i = 0; i < 3; i++) {

​                     System.out.println("Hi from Ex1RunnerB");       

​                     Thread.yield();

​              }

​              System.out.println("Ex1RunnerB task complete.");

​              return;

​       }

}

 

class Ex1RunnerC implements Runnable {

​       public Ex1RunnerC() {

​              System.out.println("Constructing Ex1RunnerC");

​       }

​       public void run() {

​              for(int i = 0; i < 3; i++) {

​                     System.out.println("Hi from Ex1RunnerC");       

​                     Thread.yield();

​              }

​              System.out.println("Ex1RunnerC task complete.");

​              return;    

​       }

}

 

public class Ex1 {

​       public static void main(String[] args) {

​              Thread ta = new Thread(new Ex1RunnerA());           

​              Thread tb = new Thread(new Ex1RunnerB());           

​              Thread tc = new Thread(new Ex1RunnerC());

​              ta.start();

​              tb.start();

​              tc.start();

​       }

}      

 

class Ex3RunnerA implements Runnable {

​       public Ex3RunnerA() {

​              System.out.println("Constructing Ex3RunnerA");

​       }

​       public void run() {

​              for(int i = 0; i < 3; i++) {

​                     System.out.println("Hi from Ex3RunnerA");       

​                     Thread.yield();

​              }

​              System.out.println("Ex3RunnerA task complete.");

​              return;                         

​       }

}

 

class Ex3RunnerB implements Runnable {

​       public Ex3RunnerB() {

​              System.out.println("Constructing Ex3RunnerB");

​       }

​       public void run() {

​              for(int i = 0; i < 3; i++) {

​                     System.out.println("Hi from Ex3RunnerB");       

​                     Thread.yield();

​              }

​              System.out.println("Ex3RunnerB task complete.");

​              return;

​       }

}

 

class Ex3RunnerC implements Runnable {

​       public Ex3RunnerC() {

​              System.out.println("Constructing Ex3RunnerC");

​       }

​       public void run() {

​              for(int i = 0; i < 3; i++) {

​                     System.out.println("Hi from Ex3RunnerC");       

​                     Thread.yield();

​              }

​              System.out.println("Ex3RunnerC task complete.");

​              return;    

​       }

}

 

public class Ex3 {

​       public static void main(String[] args) {

​              ExecutorService exec1 = Executors.newCachedThreadPool();

​              exec1.execute(new Ex3RunnerA());

​              exec1.execute(new Ex3RunnerB());

​              exec1.execute(new Ex3RunnerC());

​              exec1.shutdown();

​              ExecutorService exec2 = Executors.newFixedThreadPool(3);

​              exec2.execute(new Ex3RunnerA());

​              exec2.execute(new Ex3RunnerB());

​              exec2.execute(new Ex3RunnerC());

​              exec2.shutdown();

​              ExecutorService exec3 = Executors.newSingleThreadExecutor();

​              exec3.execute(new Ex3RunnerA());

​              exec3.execute(new Ex3RunnerB());

​              exec3.execute(new Ex3RunnerC());

​              exec3.shutdown();

​       }

}      

 

class Ex4FibonacciA implements Runnable {

​       private int n = 0;

​       public Ex4FibonacciA(int n) {

​              this.n = n;

​       }

​       private int fib(int x) {

​              if(x < 2) return 1;

​              return fib(x - 2) + fib(x - 1);

​       }

​       public void run() {

​              for(int i = 0; i < n; i++)

​                     print(fib(i) + " ");

​                     println();         

​       }

}

 

class Ex4FibonacciB implements Runnable {

​       private int n = 0;

​       public Ex4FibonacciB(int n) {

​              this.n = n;

​       }

​       private int fib(int x) {

​              if(x < 2) return 1;

​              return fib(x - 2) + fib(x - 1);

​       }

​       public void run() {

​              for(int i = 0; i < n; i++)

​                     print(fib(i) + " ");

​                     println();         

​       }

}

 

class Ex4FibonacciC implements Runnable {

​       private int n = 0;

​       public Ex4FibonacciC(int n) {

​              this.n = n;

​       }

​       private int fib(int x) {

​              if(x < 2) return 1;

​              return fib(x - 2) + fib(x - 1);

​       }

​       public void run() {

​              for(int i = 0; i < n; i++)

​                     print(fib(i) + " ");    

​                     println();  

​       }

}

 

class Ex4FibonacciD implements Runnable {

​       private int n = 0;

​       public Ex4FibonacciD(int n) {

​              this.n = n;

​       }

​       private int fib(int x) {

​              if(x < 2) return 1;

​              return fib(x - 2) + fib(x - 1);

​       }

​       public void run() {

​              for(int i = 0; i < n; i++)

​                     print(fib(i) + " ");    

​                     println();  

​       }

}

 

public class Ex4 {

​       public static void main(String[] args) {

​              ExecutorService exec1 = Executors.newCachedThreadPool();

​              exec1.execute(new Ex4FibonacciA(15));             

​              exec1.execute(new Ex4FibonacciB(15));             

​              exec1.execute(new Ex4FibonacciC(15));

​              exec1.execute(new Ex4FibonacciD(15));

​              exec1.shutdown();        

​              ExecutorService exec2 = Executors.newFixedThreadPool(4);

​              exec2.execute(new Ex4FibonacciA(15));             

​              exec2.execute(new Ex4FibonacciB(15));             

​              exec2.execute(new Ex4FibonacciC(15));

​              exec2.execute(new Ex4FibonacciD(15));

​              exec2.shutdown();

​              ExecutorService exec3 = Executors.newSingleThreadExecutor();

​              exec3.execute(new Ex4FibonacciA(15));             

​              exec3.execute(new Ex4FibonacciB(15));             

​              exec3.execute(new Ex4FibonacciC(15));

​              exec3.execute(new Ex4FibonacciD(15));

​              exec3.shutdown(); 

​       }

}       

 

class Ex5Fibonacci implements Callable<Integer> {

​       private int n = 0;

​       public Ex5Fibonacci(int n) {

​              this.n = n;

​       }

​       private int fib(int x) {

​              if(x < 2) return 1;

​              return fib(x - 2) + fib(x - 1);

​       }

​       public Integer call() {

​              int result = 0;

​              for(int i = 0; i < n; i++) 

​                     result += fib(i);             

​              return (Integer)result;

​       }

}

 

public class Ex5 {

​       public static void main(String[] args) {

​              ExecutorService exec = Executors.newCachedThreadPool();

​              ArrayList<Future<Integer>> results = new ArrayList<Future<Integer>>();

​              for(int i = 0; i < 20; i++)

​                     results.add(exec.submit(new Ex5Fibonacci(i)));

​              for(Future<Integer> fs : results)

​                     try {

​                                                       System.out.println(fs.get());

​                     } catch(InterruptedException e) {

​                            System.out.println(e);

​                            return;

​                     } catch(ExecutionException e) {

​                            System.out.println(e);    

​                     } finally {

​                            exec.shutdown();

​                     }                           

​       }

}

public class Ex6 implements Runnable {

​       Random rand = new Random();

​       public void run() {

​              try {

​                     int t = 1000 * rand.nextInt(10);

​                     TimeUnit.MILLISECONDS.sleep(t);       

​                     System.out.println("Slept " + t                  return;                  

​              } catch(InterruptedException e) {

​                     System.err.println("Interrupted");

​              }

​              

​       }

​       public static void main(String[] args) {

​              if(args.length < 1) {

​                     System.out.println("Usage: enter a number");

​              }             

​              if(args.length == 1) {

​                     int n = Integer.parseInt(args[0]);

​                     ExecutorService exec = Executors.newCachedThreadPool();

​                     for(int i = 0; i < n; i++)

​                            exec.execute(new Ex6());

​                     exec.shutdown();

​              }

​       }

}

 

class Daemon implements Runnable {

​       private Thread[] t = new Thread[30];

​       public void run() {

​              for(int i = 0; i < t.length; i++) {

​                     t[i] = new Thread(new DaemonSpawn());

​                     t[i].start();

​                     printnb("DaemonSpawn " + i + " started, ");

​              }

​              for(int i = 0; i < t.length; i++)

​                     printnb("t[" + i + "].isDaemon() = " + 

​                            t[i].isDaemon() + ", ");

​              while(true)

​                     Thread.yield();

​       }

}

 

class DaemonSpawn implements Runnable {

​       public void run() {

​              while(true)

​                     Thread.yield();

​       }

}

 

public class Daemons7 {

​       public static void main(String[] args) throws Exception {

​              Thread d = new Thread(new Daemon());

​              d.setDaemon(true);

​              d.start();

​              printnb("d.isDaemon() = " + d.isDaemon() + ", ");

​                                 }

}

public class MoreBasicThreads8 {

​       public static void main(String[] args) {

​              try {                     for(int i = 0; i < 25; i++) { 

​                            Thread t = new Thread(new LiftOff());

​                            t.setDaemon(true);

​                            t.start();                        

​                     }

​                     System.out.println("Waiting for LiftOff");    

​              

​              } finally {

​                     System.out.println("Finally out of main");

​              }

​       }

}

 

class SimplePriorities9ThreadFactory implements ThreadFactory {

​       Random rand = new Random();

​       public Thread newThread(Runnable r) {

​              Thread t = new Thread(r);

​              int i = rand.nextInt(3);

​              switch(i) {

​                     case 0 : t.setPriority(MIN_PRIORITY); break;

​                     case 1 : t.setPriority(NORM_PRIORITY); break;

​                     case 2 : t.setPriority(MAX_PRIORITY); break;

​                     default:   

​              }

​              return t;  

​       }

}

 

public class SimplePriorities9 implements Runnable {

​       private int countDown = 5;

​       private volatile double d;   public String toString() {

​              return Thread.currentThread() + ": " + countDown;

​       }

​       public void run() {

​              while(true) {

​                                         for(int i = 0; i < 100000; i++) {

​                            d += (Math.PI + Math.E)                         if(i % 1000 == 0)

​                                   Thread.yield();

​                     } 

​              System.out.println(this);

​              if(--countDown == 0) return;

​              }             

​       }

​       public static void main(String[] args) throws Exception {

​              ExecutorService exec = 

​                     Executors.newCachedThreadPool(new SimplePriorities9ThreadFactory());

​              for(int i = 0; i < 5; i++)

​                     exec.execute(new SimplePriorities9());

​              exec.execute(new SimplePriorities9());

​              exec.shutdown();

​                     

​       }

}

 

class Ex10Fibonacci implements Callable<Integer> {

​       private Integer n = 0;

​       ExecutorService exec = Executors.newSingleThreadExecutor();

​       private int fib(int x) {

​              if(x < 2) return 1;

​              return fib(x - 2) + fib(x - 1);

​       }      

​       public Integer call() {

​              int result = 0;

​              for(int i = 0; i < n; i++) 

​                     result += fib(i);             

​              return (Integer)result;

​       }

​       public Future<Integer> runTask(Integer n) {

​              this.n = n;      

​              return exec.submit(this);              

​       }

}

 

public class Ex10 {

​       public static void main(String[] args) {       

​              Ex10Fibonacci fib = new Ex10Fibonacci();

​              try {

​                     for(int i = 0; i < 15; i++) {

​                            print("Sum of first " + i + 

​                                   " Fibonacci numbers = ");

​                            println(fib.runTask(i).get());

 

​                     }                    

​              } catch(InterruptedException e) {

​                     System.out.println(e);

​                     return;

​              } catch(ExecutionException e) {

​                     System.out.println(e);    

​              } finally {

​                     fib.exec.shutdown();

​              }                    

​       }

}

 

abstract class NumRangeGenerator {       private volatile boolean canceled = false;

​       public abstract int[] next(); 

​       public void cancel() { canceled = true; }

​       public boolean isCanceled() { return canceled; }

}

 

class NumRangeChecker11 implements Runnable {      private NumRangeGenerator generator;

​       private final int id;

​       public NumRangeChecker11(NumRangeGenerator g, int ident) {

​              generator = g;

​              id = ident;

​       }

​       public void run() {

​              System.out.println("Testing..");

​              while(!generator.isCanceled()) {

​                     int[] range = generator.next();

​                    if( range[0] > range[1]) {

​                            System.out.println("Error in test #" + id + ": min " + range[0] 

​                                   + " > " + "max " + range[1] );

​                            generator.cancel();

​                     }

​              }

​       }

​       public static void test(NumRangeGenerator gen, int count) {

​              System.out.println("Press Ctrl-C to exit");

​              ExecutorService exec = Executors.newCachedThreadPool();

​              for(int i = 0; i < count; i++) 

​                     exec.execute(new NumRangeChecker11(gen, i));            

​              exec.shutdown();

​       }

​       public static void test(NumRangeGenerator gen) {

​              test(gen, 10);

​       }

}

 

public class NumRangeGenerator11 extends NumRangeGenerator {

​       private int min = 0;

​       private int max = 0;

​       private int[] range = { min, max };

​       private Random rand = new Random();

​       public int[] next() {             min = rand.nextInt(100);

​              max = rand.nextInt(100);

​              Thread.yield();

​              if(min > max) max = min;

​              int[] ia = { min, max };

​              return ia;

​       }      

​       public static void main(String[] args) {

​              NumRangeChecker11.test(new NumRangeGenerator11());

​       }

}

 

public class AtomicityTest12 implements Runnable {

​       private int i = 0;

​       public synchronized int getValue() { return i; }

​       private synchronized void evenIncrement() { i++; i++; } 

​       public void run() {

​              while(true) {

​                     evenIncrement();

​              }

​       }

​       public static void main(String[] args) {

​              ExecutorService exec = Executors.newCachedThreadPool();

​              AtomicityTest12 at = new AtomicityTest12();

​              exec.execute(at);

​              while(true) {

​                     int val = at.getValue();

​                     if(val % 2 != 0) {

​                            System.out.println(val);

​                            System.exit(0);

​                     }

​              }

​       }

}

 

 class CircularSet {

​       private int[] array;

​       private int len;

​       private int index = 0;

​       public CircularSet(int size) {

​              array = new int[size];

​              len = size;

​                                        for(int i = 0; i < size; i++)

​                     array[i] = -1;

​       }

​       public synchronized void add(int i) {

​              array[index] = i;

​                           index = ++index % len;

​       }

​       public synchronized boolean contains(int val) {

​              for(int i = 0; i < len; i++)

​                     if(array[i] == val) return true;

​              return false;

​       }

}

 

public class SerialNumberChecker13 {       

​       private static final int SIZE = 10;

​       private static CircularSet serials = new CircularSet(1000);

​       private static ExecutorService exec = Executors.newCachedThreadPool();

​       static class SerialChecker13 implements Runnable {

​              public void run() {

​                     while(true) {

​                            int serial = SerialNumberGenerator13.nextSerialNumber();

​                            if(serials.contains(serial)) {

​                                   System.out.println("Duplicate: " + serial);

​                                   System.exit(0);

​                            }

​                            serials.add(serial);

​                     }

​              }

​       }

​       public static void main(String[] args) throws Exception {

​              for(int i = 0; i < SIZE; i++)

​                     exec.execute(new SerialChecker13());

​                           if(args.length > 0) {

​                     TimeUnit.SECONDS.sleep(new Integer(args[0]));

​                     System.out.println("No duplicates detected");

​                     System.exit(0);

​              }

​       }      

}

 

 

public class Ex14 implements Runnable {

​       private static int timers = 0;

​       private static int tasks = 0;

​       public void run() {

​              try {

​                     while(timers < 4000) {                             ++timers;

​                            Timer t = new Timer();         

​                            t.schedule(new TimerTask() {

​                                   public void run() {

​                                          ++tasks; 

​                                          if(timers % 100 == 0)           

​                                                 System.out.println(timers + " timers did " 

​                                                        + tasks + " tasks");

​                                   }

​                            }, 0);

​                            try {

​                                   TimeUnit.MILLISECONDS.sleep(30);                              } catch(InterruptedException e) {

​                                   System.out.println("Sleep interrupted");

​                            }

​                            t.cancel();

​                     }

​              } finally {

​                     System.out.println("Done. " + timers + " timers completed " 

​                            + tasks + " tasks");

​              } 

​       }

​       public static void main(String[] args) {

​              ExecutorService exec = Executors.newCachedThreadPool();

​              exec.execute(new Ex14());

​              exec.shutdown();

​       }

}

 

 

class SyncTest1 {         public void f1() {

​              synchronized(this) {

​                     for(int i = 0; i < 5; i++) {

​                            print("f1()");

​                            Thread.yield();

​                     }

​              }

​       }

​       public void g1() {

​              synchronized(this) {

​                     for(int i = 0; i < 5; i++) {

​                            print("g1()");

​                            Thread.yield();

​                     }

​              }

​       }

​       public void h1() {

​              synchronized(this) {

​                     for(int i = 0; i < 5; i++) {

​                            print("h1()");

​                            Thread.yield();

​                     }

​              }

​       }

}

 

class SyncTest2 {         private Object syncObject1 = new Object();

​       private Object syncObject2 = new Object();

​       private Object syncObject3 = new Object();

​       public void f2() {

​              synchronized(syncObject1) {

​                     for(int i = 0; i < 5; i++) {

​                            print("f2()");

​                            Thread.yield();

​                     }

​              }

​       }

​       public void g2() {

​              synchronized(syncObject2) {

​                     for(int i = 0; i < 5; i++) {

​                            print("g2()");

​                            Thread.yield();

​                     }

​              }

​       }

​       public void h2() {

​              synchronized(syncObject3) {

​                     for(int i = 0; i < 5; i++) {

​                            print("h2()");

​                            Thread.yield();

​                     }

​              }

​       }

}

 

public class Ex15 {

​       public static void main(String[] args) {

​              final SyncTest1 st1 = new SyncTest1();

​              final SyncTest2 st2 = new SyncTest2();

​              new Thread() {

​                     public void run() {

​                            st1.f1();

​                     }

​              }.start();

​              new Thread() {

​                     public void run() {

​                            st1.g1();

​                     }

​              }.start();

​              new Thread() {

​                     public void run() {

​                            st1.h1();

​                     }

​              }.start();          

​              new Thread() {

​                     public void run() {

​                            st2.f2();

​                     }

​              }.start();

​              new Thread() {

​                     public void run() {

​                            st2.g2();

​                     }

​              }.start();

​              new Thread() {

​                     public void run() {

​                            st2.h2();

​                     }

​              }.start();                 

​       }

}

 

 

class SyncTest1 {         private Lock lock = new ReentrantLock();

​       public void f1() {

​              lock.lock();

​              try {

​                     for(int i = 0; i < 5; i++) {

​                            print("f1()");

​                            Thread.yield();

​                     }

​              } finally {

​                     lock.unlock();

​              }             

​       }

​       public void g1() {

​              lock.lock();

​              try {

​                     for(int i = 0; i < 5; i++) {

​                            print("g1()");

​                            Thread.yield();

​                     }

​              } finally {

​                     lock.unlock();

​              }      

​       }

​       public void h1() {

​              lock.lock();

​              try {

​                     for(int i = 0; i < 5; i++) {

​                            print("h1()");

​                            Thread.yield();

​                     }

​              } finally {

​                     lock.unlock();

​              }      

​       }

}

 

class SyncTest2 {         private Lock lock1 = new ReentrantLock();

​       private Lock lock2 = new ReentrantLock();

​       private Lock lock3 = new ReentrantLock();

​       

​       public void f2() {

​              lock1.lock();

​              try {

​                     for(int i = 0; i < 5; i++) {

​                            print("f2()");

​                            Thread.yield();

​                     }

​              } finally {

​                     lock1.unlock();

​              }

​       }

​       public void g2() {

​              lock2.lock();

​              try {

​                     for(int i = 0; i < 5; i++) {

​                            print("g2()");

​                            Thread.yield();

​                     }

​              } finally {

​                     lock2.unlock();

​              }

​       }

​       public void h2() {

​              lock3.lock();

​              try {

​                     for(int i = 0; i < 5; i++) {

​                            print("h2()");

​                            Thread.yield();

​                     }

​              } finally {

​                     lock3.unlock();

​              }

​       }

}

 

public class Ex16 {

​       public static void main(String[] args) {

​              final SyncTest1 st1 = new SyncTest1();

​              final SyncTest2 st2 = new SyncTest2();

​              new Thread() {

​                     public void run() {

​                            st1.f1();

​                     }

​              }.start();

​              new Thread() {

​                     public void run() {

​                            st1.g1();

​                     }

​              }.start();

​              new Thread() {

​                     public void run() {

​                            st1.h1();

​                     }

​              }.start();          

​              new Thread() {

​                     public void run() {

​                            st2.f2();

​                     }

​              }.start();

​              new Thread() {

​                     public void run() {

​                            st2.g2();

​                     }

​              }.start();

​              new Thread() {

​                     public void run() {

​                            st2.h2();

​                     }

​              }.start();                 

​       }

}

 

 

class RadCount {

​       private int count = 0;

​       private Random rand = new Random();

​       public synchronized int increment() {

​              return count++;

​       }

​       public synchronized int value() { return count; } 

}

 

class Sensor implements Runnable {

​       private static RadCount count = new RadCount();

​       private static List<Sensor> sensors = new ArrayList<Sensor>();

​       private int number = 0;

​             private final int id;

​       private static volatile boolean canceled = false;

​             public static void cancel() { canceled = true; }

​       public Sensor(int id) {

​              this.id = id;

​                                        sensors.add(this);

​       }

​       public void run() {

​              while(!canceled) {

​                     synchronized(this) {

​                            ++number;

​                     }

​                     print(this + " Total: " + count.increment());

​                     try {

​                            TimeUnit.MILLISECONDS.sleep(25);

​                     } catch(InterruptedException e) {

​                            print("sleep interrupted");

​                     }

​              }

​              print("Stopping " + this);

​       }

​       public synchronized int getValue() { return number; }

​       public String toString() {

​              return "Sensor " + id + ": " + getValue();

​       } 

​       public static int getTotalCount() {

​              return count.value();

​       }

​       public static int sumSensors() {

​              int sum = 0;

​              for(Sensor sensor : sensors)

​                     sum += sensor.getValue();

​              return sum;

​       }

}

 

public class RadiationCounter17 {

​       public static void main(String[] args) throws Exception {

​              ExecutorService exec = Executors.newCachedThreadPool();

​              for(int i = 0; i < 10; i++)

​                     exec.execute(new Sensor(i));

​                           TimeUnit.SECONDS.sleep(4);

​              Sensor.cancel();

​              exec.shutdown();

​              if(!exec.awaitTermination(250, TimeUnit.MILLISECONDS))

​                     print("Some tasks were not terminated");

​              print("Total: " + Sensor.getTotalCount());

​              print("Sum of Sensors: " + Sensor.sumSensors());

​       }

}

 

class Nontask {

​       public static void rest() {

​              try {

​                     TimeUnit.SECONDS.sleep(5);

​              } catch(InterruptedException e) {

​                     System.out.println("Sleep interrupted");

​              } finally {

​                     System.out.println("Good Bye");

​              }

​       }

}

 

class Worker implements Runnable {

​       public void run() {

​              Nontask.rest();              

​       }

}

 

public class Ex18 {

​       public static void main(String[] args) { 

​                                        Thread t = new Thread(new Worker());

​              t.start();

​              t.interrupt();

​                           ExecutorService exec = Executors.newSingleThreadExecutor();

​              exec.execute(new Worker());              

​              exec.shutdownNow();

​                           ExecutorService exec2 = Executors.newSingleThreadExecutor();

​              Future<?> f = exec2.submit(new Worker());

​              try {

​                     TimeUnit.MILLISECONDS.sleep(100);              } catch(InterruptedException e) {

​                     System.out.println("Sleep interrupted in main()");

​              }

​              f.cancel(true);

​              exec2.shutdown();        

​       }

}

 

class Count {

​       private int count = 0;

​       private Random rand = new Random(47);

​             public synchronized int increment() {

​              int temp = count;

​              if(rand.nextBoolean())                      Thread.yield();

​              return (count = ++temp);

​       }

​       public synchronized int value() { return count; } 

}

 

class Entrance implements Runnable {

​       private static Count count = new Count();

​       private static List<Entrance> entrances = new ArrayList<Entrance>();

​       private int number = 0;

​             private final int id;

​       private static volatile boolean canceled = false;

​             public static void cancel() { canceled = true; }

​       public Entrance(int id) {

​              this.id = id;

​                                        entrances.add(this);

​       }

​       public void run() {

​              while(!canceled) {

​                     synchronized(this) {                          ++number;

​                     }

​                     print(this + " Total: " + count.increment());

​                     try {

​                            TimeUnit.MILLISECONDS.sleep(50);

​                     } catch(InterruptedException e) {

​                            print("sleep interrupted");

​                            break;                 }

​              }

​              print("Stopping " + this);

​       }

​       public synchronized int getValue() { return number; }

​       public String toString() {

​              return "Entrance " + id + ": " + getValue();

​       } 

​       public static int getTotalCount() {

​              return count.value();

​       }

​       public static int sumEntrances() {

​              int sum = 0;

​              for(Entrance entrance : entrances)

​                     sum += entrance.getValue();

​              return sum;

​       }

}

 

public class OrnamentalGarden19 {

​       public static void main(String[] args) throws Exception {

​              ExecutorService exec = Executors.newCachedThreadPool();

​              for(int i = 0; i < 5; i++)

​                     exec.execute(new Entrance(i));

​                           TimeUnit.SECONDS.sleep(4);

​                           exec.shutdownNow();

​              if(!exec.awaitTermination(250, TimeUnit.MILLISECONDS))

​                     print("Some tasks were not terminated");

​              print("Total: " + Entrance.getTotalCount());

​              print("Sum of Entrances: " + Entrance.sumEntrances());

​       }

}

 

public class CachedThreadPool20 {

​       public static void main(String[] args) throws Exception {

​              System.out.println("Using LiftOff:");

​              ExecutorService exec = Executors.newCachedThreadPool();

​              for(int i = 0; i < 5; i++) {

​                     Future<?> f = exec.submit(new LiftOff());

​                     f.cancel(true);                                           

​              }

​              exec.shutdownNow();

​              if(!exec.awaitTermination(250, TimeUnit.MILLISECONDS))

​                     System.out.println("Some tasks were not terminated");

​                           System.out.println("\nUsing LiftOff20:"); 

​              ExecutorService exec20 = Executors.newCachedThreadPool();

​              for(int i = 0; i < 5; i++) {

​                     Future<?> f = exec20.submit(new LiftOff20());

​                     f.cancel(true);                             

​              }

​              exec20.shutdownNow();

​              if(!exec.awaitTermination(250, TimeUnit.MILLISECONDS))

​                     System.out.println("Some tasks were not terminated");          

​       }

}

 

 

class A implements Runnable {

​       private volatile boolean signal = false;

​       public synchronized void run() {               try {

​                     while(!signal) {                                                                          println("A.run() wait()");

​                                                       wait();

​                            signal = true;

​                            println("A is done waiting");                            

​                     }                    

​              } catch(InterruptedException e) {

​                     println("A run() interrupted");      

​              } finally {

​                     println("Leaving A.run()");    

​              }             

​       }

​       public synchronized void message() {

​              println("Hi from A");

​       }             

}

 

class B implements Runnable {    

​       private A a;

​       public A getA() { return a; }

​       B(A a) { this.a = a; } 

​       public void run() {

​              try { 

​                     TimeUnit.MILLISECONDS.sleep(2000);

​                     synchronized(a) {                             println("B.run() a.notifyAll()");

​                            a.notifyAll();

​                     }

​              } catch(InterruptedException e) {

​                    System.out.println("B sleep interrupted");

​              }             

​       }      

}

 

public class Ex21 {

​       public static void main(String[] args) {

​              ExecutorService exec = Executors.newCachedThreadPool();

​              B b = new B(new A());

​              exec.execute(b.getA());

​              try { 

​                     TimeUnit.MILLISECONDS.sleep(100);                

​              } catch(InterruptedException e) {

​                    System.out.println("main() sleep interrupted");

​              }

​              b.getA().message();

​              exec.execute(b);

​              try { 

​                     TimeUnit.MILLISECONDS.sleep(2500);                      

​              } catch(InterruptedException e) {

​                    System.out.println("main() sleep interrupted");

​              }             

​              exec.shutdownNow();

​       }

}

class A implements Runnable {

​       boolean flag = false;

​       public synchronized void run() {

​              try {

​                     TimeUnit.SECONDS.sleep(2);

​              } catch(InterruptedException e) {

​                     println("sleep interrupted in A");

​              }

​              println("A setting flag = true"); 

​              flag = true;            

​       }      

}

 

class BusyWait implements Runnable {

​       A a = new A();

​       long start, end;

​       public synchronized A getA() { return a; }

​       private BusyWait(A a) {

​              this.a = a;

​       }

​       public static BusyWait buildBusyWait(A a) {

​              return new BusyWait(a);

​       }

​       public synchronized void run() {

​              println("Busy a.flag = " + a.flag);         

​              while(!Thread.interrupted()) {      

​                     start = System.nanoTime();         

​                     if(a.flag) {

​                            a.flag = false;

​                            println("BusyWait reset a.flag = false");

​                            end = System.nanoTime();

​                            println("Busy waiting " + (end - start) + " nanoseconds");

​                     }

​              }             

​       }

}

 

class BetterWait implements Runnable {

​       private A a = new A();

​       public synchronized A getA() { return a; }

​       private BetterWait(A a) {

​              this.a = a;

​       }

​       public static BetterWait buildBetterWait(A a) {

​              return new BetterWait(a);

​       }

​       public synchronized void run() {

​              println("Better a.flag = " + a.flag);

​              try {               

​                     while(!a.flag) {

​                            wait();     

​                            a.flag = false;

​                            println("BetterWait reset a.flag = false");

​                     }                           

​              } catch(InterruptedException e) {

​                     println("BetterWait.run() interrupted");

​              }

​       }

}

 

public class Ex22 {

​       public static void main(String[] args) {

​              ExecutorService exec = Executors.newCachedThreadPool();

​              BusyWait busy = BusyWait.buildBusyWait(new A());

​              exec.execute(busy.a);

​              exec.execute(busy);

​              try {

​                     TimeUnit.SECONDS.sleep(3);

​              } catch(InterruptedException e) {

​                     println("sleep interrupted in main()");

​              }

​              println();

​              BetterWait better = BetterWait.buildBetterWait(new A());

​              exec.execute(better.getA());

​              exec.execute(better);

​              try {

​                     TimeUnit.SECONDS.sleep(3);

​              } catch(InterruptedException e) {

​                     println("sleep interrupted in main()");

​              }

​              synchronized(better) {

​                     println("Sending better.notifyAll()");

​                     better.notifyAll();

​              }

​              exec.shutdownNow();

​       }

}

 

class Car {

​       private boolean waxOn = false;

​       public synchronized void waxed() {

​              waxOn = true;                         notify();

​       }

​       public synchronized void buffed() {

​              waxOn = false;                        notify();

​       }

​       public synchronized void waitForWaxing() throws InterruptedException {

​              while(waxOn == false) wait();

​       }

​       public synchronized void waitForBuffing() throws InterruptedException {

​              while(waxOn == true) wait();

​       }

}      

 

class WaxOn implements Runnable {

​       private Car car;

​       public WaxOn(Car c) { car = c; }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            printnb("Wax On! ");

​                            TimeUnit.MILLISECONDS.sleep(200);

​                            car.waxed();

​                            car.waitForBuffing();

​                     }

​              } catch(InterruptedException e) {

​                     print("Exiting via interrupt");

​              }

​              print("Ending Wax On task");

​       }

}

 

class WaxOff implements Runnable {

​       private Car car;

​       public WaxOff(Car c) { car = c; }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            car.waitForWaxing();

​                            printnb("Wax Off! ");

​                            TimeUnit.MILLISECONDS.sleep(200);

​                            car.buffed();

​                     }

​              } catch(InterruptedException e) {

​                     print("Exiting via interrupt");

​              }

​              print("Ending Wax Off task");

​       }

}

 

public class WaxOMatic23 {

​       public static void main(String[] args) throws Exception {

​              Car car = new Car();

​              ExecutorService exec = Executors.newCachedThreadPool();

​              exec.execute(new WaxOff(car));

​              exec.execute(new WaxOn(car));

​              TimeUnit.SECONDS.sleep(5);            exec.shutdownNow();         }

}      

 

 

class Item {

​       private final int itemNum;

​       public Item(int itemNum) { this.itemNum = itemNum; }

​       public String toString() { return "Item " + itemNum; }

}

 

class Producer implements Runnable {

​       private int count = 0;

​       Market24 market;

​       Producer(Market24 m) { market = m; }

​       protected int getCount() { return count; }

​       public void run() {

​              while(!Thread.interrupted()) {

​                     try {

​                            while(count < 100) {

​                                   Item item = new Item(++count);

​                                   if(market.storage.offer(item)) {

​                                          println("Produced " + item);

​                                                                                   synchronized(market.consumer) { 

​                                                 market.consumer.notifyAll();

​                                          }      

​                                   }

​                                                                     synchronized(this) { 

​                                          while(!(market.storage.size() < 10)) {

​                                                 wait();

​                                          }

​                                   }

​                     }

​                                         println("Produced " + count + " Items"

​                           + "\nStopping production");

​                     market.exec.shutdownNow();      

​                     } catch(InterruptedException e) {

​                            println("Producer interrupted");

​                            println("Produced " + count + " Items"); 

​                     }                                  

​              }

​       }

}

 

class Consumer implements Runnable {

​       int consumed = 0;

​       Market24 market;

​       List<Item> cart = new ArrayList<Item>();

​       Consumer(Market24 m) { market = m; }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                                                       synchronized(this) {

​                                   while(!(cart.size() < market.producer.getCount())) {

​                                          wait();

​                                   } 

​                            }

​                                                       if(cart.add(market.storage.poll())) {

​                                   println("Consuming Item " + ++consumed); 

​                                                                     synchronized(market.producer) {

​                                          market.producer.notifyAll();

​                                   }

​                            }                    

​                     }             

​              }

​              catch(InterruptedException e) {

​                     println("Consumer interrupted");

​                     println("Consumed " + consumed + " Items");

​              }

​       }

}

 

 

public class Market24 {

​       ExecutorService exec = Executors.newCachedThreadPool();

​       Queue<Item> storage = new LinkedList<Item>();

​       Producer producer = new Producer(this);

​       Consumer consumer = new Consumer(this);

​       public Market24() {

​              exec.execute(producer);

​              exec.execute(consumer);

​       }

​       public static void main(String[] args) {

​              new Market24();

​       }

}

 

class Meal {

​       private final int orderNum;

​       public Meal(int orderNum) { this.orderNum = orderNum; }

​       public String toString() { return "Meal " + orderNum; }

}

 

class WaitPerson25 implements Runnable {

​       private Restaurant25 restaurant;

​       public WaitPerson25(Restaurant25 r) { restaurant = r; }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            synchronized(this) {

​                                   while(restaurant.meal == null)

​                                          wait();                         }

​                            print("WaitPerson25 got " + restaurant.meal);

​                            synchronized(restaurant.chef) {

​                                   restaurant.meal = null;

​                                   restaurant.chef.notifyAll();                       }

​                     }      

​              } catch(InterruptedException e) {

​                     print("WaitPerson25 interrupted");

​              }

​       }

}

 

class Chef25 implements Runnable {

​       private Restaurant25 restaurant;

​       private int count = 0;

​       public Chef25(Restaurant25 r) { restaurant = r; }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            synchronized(this) {

​                                   while(restaurant.meal != null) 

​                                          wait();                         }

​                            if(++count == 10) {

​                                   print("Out of food, closing");

​                                   restaurant.exec.shutdownNow();

​                                   return;                        }

​                            printnb("Order up! ");

​                            synchronized(restaurant.waitPerson) {

​                                   restaurant.meal = new Meal(count);

​                                   restaurant.waitPerson.notifyAll();

​                            }

​                            TimeUnit.MILLISECONDS.sleep(100);

​                     }

​              } catch(InterruptedException e) {

​                     print("Chef25 interrupted");

​              }

​       }      

}

 

public class Restaurant25 {

​       Meal meal;

​       ExecutorService exec = Executors.newCachedThreadPool();

​       WaitPerson25 waitPerson = new WaitPerson25(this);

​       Chef25 chef = new Chef25(this);

​       public Restaurant25() {

​              exec.execute(chef);

​              exec.execute(waitPerson);

​       }

​       public static void main(String[] args) {

​              new Restaurant25();

​       }

}

 

class Meal {

​       private final int orderNum;

​       public Meal(int orderNum) { this.orderNum = orderNum; }

​       public String toString() { return "Meal " + orderNum; }

}

 

class WaitPerson26 implements Runnable {

​       private Restaurant26 restaurant;

​       protected boolean clean = true;

​       protected Meal m;      public WaitPerson26(Restaurant26 r) { restaurant = r; }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            synchronized(this) {

​                                   while(restaurant.meal == null)

​                                          wait();                         }

​                            m = restaurant.meal;

​                            print("WaitPerson got " + m);

​                            synchronized(restaurant.chef) {

​                                   restaurant.meal = null;

​                                   restaurant.chef.notifyAll();                       }

​                            print("WaitPerson delivered " + m);

​                            synchronized(restaurant.busBoy) { 

​                                   clean = false;

​                                   restaurant.busBoy.notifyAll();                          }

​                     }      

​              } catch(InterruptedException e) {

​                     print("WaitPerson interrupted");

​              }

​       }

}

 

class Chef26 implements Runnable {

​       private Restaurant26 restaurant;

​       private int count = 0;

​       public Chef26(Restaurant26 r) { restaurant = r; }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            synchronized(this) {

​                                   while(restaurant.meal != null) 

​                                          wait();                         }

​                            if(++count == 10) {

​                                   print("Out of food, closing");

​                                   restaurant.exec.shutdownNow();

​                                   return;

​                            }

​                            print("Order up! ");

​                            synchronized(restaurant.waitPerson) {

​                                   restaurant.meal = new Meal(count);

​                                   restaurant.waitPerson.notifyAll();

​                            }

​                            TimeUnit.MILLISECONDS.sleep(100);

​                     }

​              } catch(InterruptedException e) {

​                     print("Chef interrupted");

​              }

​       }      

}

 

class BusBoy26 implements Runnable {

​       private Restaurant26 restaurant;

​       public BusBoy26(Restaurant26 r) { restaurant = r; }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            synchronized(this) {

​                                   while(restaurant.waitPerson.clean)

​                                          wait();

​                            }

​                            print("BusBoy cleaning up " + restaurant.waitPerson.m);

​                            restaurant.waitPerson.clean = true;

​                     }

​              } catch(InterruptedException e) {

​                     print("BusBoy interrupted");

​              }

​       }

}

 

public class Restaurant26 {

​       Meal meal;

​       ExecutorService exec = Executors.newCachedThreadPool();

​       WaitPerson26 waitPerson = new WaitPerson26(this);

​       BusBoy26 busBoy = new BusBoy26(this);

​       Chef26 chef = new Chef26(this);

​       public Restaurant26() {

​              exec.execute(chef);

​              exec.execute(waitPerson);

​              exec.execute(busBoy);

​       }

​       public static void main(String[] args) {

​              new Restaurant26();

​       }

}

 

 

 

class Meal {

​       private final int orderNum;

​       public Meal(int orderNum) { this.orderNum = orderNum; }

​       public String toString() { return "Meal " + orderNum; }

}

 

class WaitPerson27 implements Runnable {

​       private Restaurant27 restaurant;

​       protected Lock lock = new ReentrantLock();

​       protected Condition condition = lock.newCondition();

​       public WaitPerson27(Restaurant27 r) { restaurant = r; }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            lock.lock();

​                            try {

​                                   while(restaurant.meal == null)

​                                          condition.await();

​                            } finally {

​                                   lock.unlock();

​                            }

​                            print("waitPerson got " + restaurant.meal);

​                            restaurant.chef.lock.lock();

​                            try {

​                                   restaurant.meal = null;

​                                   restaurant.chef.condition.signalAll();

​                            } finally {

​                                   restaurant.chef.lock.unlock();

​                            }                           

​                     }      

​              } catch(InterruptedException e) {

​                     print("WaitPerson27 interrupted");

​              }

​       }

}

 

class Chef27 implements Runnable {

​       private Restaurant27 restaurant;

​       private int count = 0;

​       protected Lock lock = new ReentrantLock();

​       protected Condition condition = lock.newCondition();

​       public Chef27(Restaurant27 r) { restaurant = r; }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            lock.lock(); 

​                            try {

​                                   while(restaurant.meal != null)

​                                          condition.await();

​                            } finally {

​                                   lock.unlock();

​                            }

​                            if(++count == 10) {

​                                   print("Out of food, closing");

​                                   restaurant.exec.shutdownNow();

​                                   return;

​                            }

​                            printnb("Order up! ");

​                            restaurant.waitPerson.lock.lock();

​                            try {

​                                   restaurant.meal = new Meal(count);

​                                   restaurant.waitPerson.condition.signalAll();

​                            } finally {

​                                   restaurant.waitPerson.lock.unlock();

​                            }

​                            TimeUnit.MILLISECONDS.sleep(100);

​                     }

​              } catch(InterruptedException e) {

​                     print("chef interrupted");

​              }

​       }      

}

 

public class Restaurant27 {

​       Meal meal;

​       ExecutorService exec = Executors.newCachedThreadPool();

​       WaitPerson27 waitPerson = new WaitPerson27(this);

​       Chef27 chef = new Chef27(this);

​       public Restaurant27() {

​              exec.execute(chef);

​              exec.execute(waitPerson);

​       }

​       public static void main(String[] args) {

​              new Restaurant27();

​       }

}

 

class LiftOffRunner implements Runnable {

​       private BlockingQueue<LiftOff> rockets;

​       public LiftOffRunner(BlockingQueue<LiftOff> queue) {

​              rockets = queue;

​       } 

​       public void add(LiftOff lo) {

​              try {

​                     rockets.put(lo);

​              } catch(InterruptedException e) {

​                     print("Interrupted during put()");

​              }

​       }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            LiftOff rocket = rockets.take();

​                            rocket.run();                       }

​              } catch(InterruptedException e) {

​                     print("Waking from take()");

​              }

​              print("Exiting LiftOffRunner");

​       }

}

 

class LiftOffAdder implements Runnable {

​       private LiftOffRunner runner;

​       public LiftOffAdder(LiftOffRunner runner) {

​              this.runner = runner;

​       }

​       public void run() {

​              for(int i = 0; i < 5; i++)

​                     runner.add(new LiftOff(5));   

​       }

}

 

public class TestBlockingQueues28 {

​       static void getKey() {

​              try {

​                                                             new BufferedReader(new InputStreamReader(System.in)).readLine();

​              } catch(java.io.IOException e) {

​                     throw new RuntimeException(e);

​              }

​       }

​       static void getKey(String message) {

​              printnb(message);

​              getKey();

​       }

​       static void test(String msg, BlockingQueue<LiftOff> queue) {

​              print(msg);

​              LiftOffRunner runner = new LiftOffRunner(queue);

​              LiftOffAdder adder = new LiftOffAdder(runner);

​              ExecutorService exec = Executors.newCachedThreadPool();

​              exec.execute(runner);

​              exec.execute(adder);

​              getKey("Press 'Enter' (" + msg + ")");

​              print("Finished " + msg + " test");

​              exec.shutdownNow();

​       }

​       public static void main(String[] args) {

​              test("LinkedBlockingQueue",                   new LinkedBlockingQueue<LiftOff>());

​              test("ArrayBlockingQueue",                     new ArrayBlockingQueue<LiftOff>(3));

​              test("SynchronousQueue",                      new SynchronousQueue<LiftOff>());

​       }

}

 

 

class Toast {

​       public enum Status { DRY, JELLIED, PEANUTBUTTERED }

​       private Status status = Status.DRY;

​       private final int id;

​       public Toast(int idn) { id = idn; }

​       public void jelly() { status = Status.JELLIED; }

​       public void peanutButter() { status = Status.PEANUTBUTTERED; }

​       public Status getStatus() { return status; }

​       public int getId() { return id; }

​       public String toString() {

​              return "Toast " + id + ": " + status;

​       }

}

 

class ToastQueue extends LinkedBlockingQueue<Toast> {}

​       

class Toaster implements Runnable {

​       private ToastQueue toastQueue;

​       private int count = 0;

​       private Random rand = new Random();

​       public Toaster(ToastQueue tq) { toastQueue = tq; }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            TimeUnit.MILLISECONDS.sleep(

​                                   100 + rand.nextInt(500));

​                                                       Toast t = new Toast(count++);

​                            print(t);

​                                                       toastQueue.put(t);

​                     }

​              } catch(InterruptedException e) {

​                     print("Toaster interrupted");

​              }

​              print("Toaster off");

​       }

}

 

 class PeanutButterer implements Runnable {

​       private ToastQueue dryQueue, peanutButteredQueue;

​       public PeanutButterer(ToastQueue dry, ToastQueue peanutButtered) {

​              dryQueue = dry;

​              peanutButteredQueue = peanutButtered;

​       }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                                                       Toast t = dryQueue.take();

​                            t.peanutButter();

​                            print(t);

​                            peanutButteredQueue.put(t);

​                     }

​              } catch(InterruptedException e) {

​                    print("PeanutButterer interrupted");

​              }

​              print("PeanutButterer off");

​       }

}

 

 class Jellyer implements Runnable {

​       private ToastQueue dryQueue, jelliedQueue;

​       public Jellyer(ToastQueue dry, ToastQueue jellied ) {

​              dryQueue = dry;

​              jelliedQueue = jellied;

​       }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                                                       Toast t = dryQueue.take();

​                            t.jelly();

​                            print(t);

​                            jelliedQueue.put(t);

​                     }

​              } catch(InterruptedException e) {

​                     print("Jellyer interrupted");

​              }

​              print("Jellyer off");

​       }

}

 

class Sandwich {

​       private Toast top, bottom;

​       private final int id;

​       public Sandwich(Toast top, Toast bottom, int id) {

​              this.top = top;

​              this.bottom = bottom;

​              this.id = id;

​       }

​       public int getId() {

​              return id;

​       }

​       public Toast getTop() { return top; }

​       public Toast getBottom() { return bottom; }

​       public String toString() {

​              return "Sandwich " + id + ": top: " + top + " and bottom: " + bottom;

​       }

}

 

class SandwichQueue extends LinkedBlockingQueue<Sandwich> {}

 

 class SandwichMaker implements Runnable {

​       private int count = 0;

​       private ToastQueue jelliedQueue, peanutButteredQueue;

​       private SandwichQueue sandwichQueue;

​       public SandwichMaker(ToastQueue jellied, ToastQueue peanutButtered, SandwichQueue sq) {

​              jelliedQueue = jellied;

​              peanutButteredQueue = peanutButtered;

​              sandwichQueue = sq;

​       }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            Sandwich s = new Sandwich(

​                                   jelliedQueue.take(), peanutButteredQueue.take(), count++);

​                            print(s);

​                            sandwichQueue.put(s);

​                     }

​              } catch(InterruptedException e) {

​                     print("SandwichMaker interrupted");

​              }

​              print("Sandwich maker off");

​       }

}

 

 class SandwichEater implements Runnable {

​       private SandwichQueue sandwichQueue;

​       private int counter = 0;

​       public SandwichEater(SandwichQueue sq) {

​              sandwichQueue = sq;

​       }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                                                       Sandwich s = sandwichQueue.take();

​                                                                                  if(s.getId() != counter++ || 

​                                   s.getTop().getStatus() != Toast.Status.JELLIED || 

​                                   s.getBottom().getStatus() != Toast.Status.PEANUTBUTTERED) {

​                                          print(">>>> Error: " + s);

​                                          System.exit(1);

​                            } else

​                                   print("NumNum! " + s);

​                     } 

​              } catch(InterruptedException e) {

​                            print("SandwichEater interruped");

​              }

​              print("SandwichEater off");

​       }

}

 

public class ToastOMatic29 {

​       public static void main(String[] args) throws Exception {

​              ToastQueue dryQueue = new ToastQueue(),

​                     jelliedQueue = new ToastQueue(),

​                     peanutButteredQueue = new ToastQueue();

​              SandwichQueue sandwichQueue = new SandwichQueue();

​              ExecutorService exec = Executors.newCachedThreadPool();

​              exec.execute(new Toaster(dryQueue));

​              exec.execute(new Jellyer(dryQueue, jelliedQueue));

​              exec.execute(new PeanutButterer(dryQueue, peanutButteredQueue));

​              exec.execute(new SandwichMaker(

​                     jelliedQueue, peanutButteredQueue, sandwichQueue));

​              exec.execute(new SandwichEater(sandwichQueue));

​              TimeUnit.SECONDS.sleep(5);

​              exec.shutdownNow();

​       }

}

 

class Sender implements Runnable {

​       private Random rand = new Random(47);

​       private LinkedBlockingQueue<Character> queue;

​       public Sender(LinkedBlockingQueue<Character> lbq) {

​              queue = lbq;

​       }

​       public void run() {

​              try {

​                     while(true)

​                            for(char c = 'A'; c <= 'z'; c++) {

​                                   queue.put(c);

​                                   TimeUnit.MILLISECONDS.sleep(rand.nextInt(500));

​                            }

​              } catch(InterruptedException e) {

​                     print(e + " Sender sleep interrupted");

​              }

​       }

}

 

class Receiver implements Runnable {

​       private LinkedBlockingQueue<Character> queue;

​       public Receiver(LinkedBlockingQueue<Character> lbq) {

​              queue = lbq;

​       }

​       public void run() {

​               try {

​                     while(true) {

​                                                       printnb("Read: " + (char)queue.take() + ", ");

​                     }

​               } catch(InterruptedException e) {

​                     print(e + " Receiver read exception");

​              }

​       }

}

 

public class Ex30 {

​       public static void main(String[] args) throws Exception {

​              LinkedBlockingQueue<Character> lbq = new LinkedBlockingQueue<Character>();

​              Sender sender = new Sender(lbq);

​              Receiver receiver = new Receiver(lbq);

​              ExecutorService exec = Executors.newCachedThreadPool();

​              exec.execute(sender);

​              exec.execute(receiver);

​              TimeUnit.SECONDS.sleep(4);

​              exec.shutdownNow();

​       }

}

 

public class Philosopher31 implements Runnable {

​       private Chopstick left;

​       private Chopstick right;

​       private LinkedBlockingQueue<Chopstick> bin;

​       private final int id;

​       private final int ponderFactor;

​       private Random rand = new Random(47);

​       private void pause() throws InterruptedException {

​              if(ponderFactor == 0) return;

​              TimeUnit.MILLISECONDS.sleep(rand.nextInt(ponderFactor * 250));

​       }

​       public Philosopher31(Chopstick left, Chopstick right, 

​              LinkedBlockingQueue<Chopstick> bin, int ident, int ponder) {

​              this.left = left;

​              this.right = right;

​              this.bin = bin;

​              id = ident;

​              ponderFactor = ponder;

​       }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            print(this + " " + "thinking");

​                            pause();

​                                                       print(this + " taking first, right chopstick");

​                            right = bin.take();

​                            print(this + " taking second, left chopstick");

​                            left = bin.take();

​                            print(this + " eating");

​                            pause();

​                            print(this + " returning chopsticks");

​                            bin.put(right);

​                            bin.put(left);

​                     }

​              } catch(InterruptedException e) {

​                     print(this + " " + "exiting via interrupt");

​              }

​       }

​       public String toString() { return "Philosopher " + id; }

}

 

public class DeadlockingDiningPhilosophers31 {

​       public static void main(String[] args) throws Exception {

​              int ponder = 5;

​              if(args.length > 0)

​                     ponder = Integer.parseInt(args[0]);

​              int size = 5;

​              if(args.length > 1)

​                     size = Integer.parseInt(args[1]);

​              ExecutorService exec = Executors.newCachedThreadPool();

​                           LinkedBlockingQueue<Chopstick> bin = new LinkedBlockingQueue<Chopstick>();

​              Chopstick[] sticks = new Chopstick[size];

​              for(int i = 0; i < size; i++) {

​                     sticks[i] = new Chopstick();

​                     bin.put(sticks[i]);

​              }      

​              for(int i = 0; i < size; i++)     

​                     exec.execute(new Philosopher31(sticks[i], sticks[(i + 1) % size], bin, i, ponder));

​              if(args.length == 3 && args[2].equals("timeout"))

​                     TimeUnit.SECONDS.sleep(5);

​              else {

​                     System.out.println("Press 'Enter' to quit");

​                     System.in.read();

​              }

​              exec.shutdownNow();

​       }

}

 

import java.util.concurrent.*;

import java.util.*;

import static net.mindview.util.Print.*;

 

class Count {

​       private int count = 0;

​       private Random rand = new Random(47);

​             public synchronized int increment() {

​              int temp = count;

​              if(rand.nextBoolean())                      Thread.yield();

​              return (count = ++temp);

​       }

​       public synchronized int value() { return count; } 

}

 

class Entrance implements Runnable {

​       private static Count count = new Count();

​       private static List<Entrance> entrances = new ArrayList<Entrance>();

​       private int number = 0;

​       private final int id;

​       private final CountDownLatch doneSignal;

​       private static CountDownLatch stopSignal;

​       public Entrance(int id, CountDownLatch doneSignal, CountDownLatch stopSignal) {

​              this.id = id;

​              this.doneSignal = doneSignal;

​              this.stopSignal = stopSignal;

​                                        entrances.add(this);

​       }

​       public void run() {

​              while(!(stopSignal.getCount() == 0)) {

​                     synchronized(this) {

​                            ++number;

​                     }

​                     print(this + " Total: " + count.increment());

​                     try { 

​                            TimeUnit.MILLISECONDS.sleep(100);

​                     } catch(InterruptedException e) {

​                            print("sleep interrupted");

​                     }

​              }

​              print("Closing " + this);

​              doneSignal.countDown();

​       }

​       public synchronized int getValue() { return number; }

​       public String toString() {

​              return "Entrance " + id + ": " + getValue();

​       } 

​       public static int getTotalCount() {

​              return count.value();

​       }

​       public static int sumEntrances() {

​              int sum = 0;

​              for(Entrance entrance : entrances)

​                     sum += entrance.getValue();

​              return sum;

​       }

}

 

public class OrnamentalGarden32 {

​       public static void main(String[] args) throws Exception {

​              int SIZE = 5;

​              CountDownLatch stopSignal = new CountDownLatch(1);

​              CountDownLatch doneSignal = new CountDownLatch(SIZE);

​              ExecutorService exec = Executors.newCachedThreadPool();

​              for(int i = 0; i < SIZE; i++)

​                     exec.execute(new Entrance(i, doneSignal, stopSignal));

​                           TimeUnit.SECONDS.sleep(2);

​                           stopSignal.countDown();

​                           doneSignal.await();

​              exec.shutdown();

​              print("Total: " + Entrance.getTotalCount());

​              print("Sum of Entrances: " + Entrance.sumEntrances());

​       }

}

 

class Count {

​       private int count = 0;

​       private Random rand = new Random(47);

​             public synchronized int increment() {

​              int temp = count;

​              if(rand.nextBoolean())                      Thread.yield();

​              return (count = ++temp);

​       }

​       public synchronized int value() { return count; } 

}

 

class Entrance implements Runnable {

​       private static Count count = new Count();

​       private static List<Entrance> entrances = new ArrayList<Entrance>();

​       private int number = 0;

​       private final int id;

​       private final CountDownLatch doneSignal;

​       private static CountDownLatch stopSignal;

​       public Entrance(int id, CountDownLatch doneSignal, CountDownLatch stopSignal) {

​              this.id = id;

​              this.doneSignal = doneSignal;

​              this.stopSignal = stopSignal;

​                                        entrances.add(this);

​       }

​       public void run() {

​              while(!(stopSignal.getCount() == 0)) {

​                     synchronized(this) {

​                            ++number;

​                     }

​                     print(this + " Total: " + count.increment());

​                     try { 

​                            TimeUnit.MILLISECONDS.sleep(100);

​                     } catch(InterruptedException e) {

​                            print("sleep interrupted");

​                     }

​              }

​              print("Closing " + this);

​              doneSignal.countDown();

​       }

​       public synchronized int getValue() { return number; }

​       public String toString() {

​              return "Entrance " + id + ": " + getValue();

​       } 

​       public static int getTotalCount() {

​              return count.value();

​       }

​       public static int sumEntrances() {

​              int sum = 0;

​              for(Entrance entrance : entrances)

​                     sum += entrance.getValue();

​              return sum;

​       }

}

 

public class OrnamentalGarden32 {

​       public static void main(String[] args) throws Exception {

​              int SIZE = 5;

​              CountDownLatch stopSignal = new CountDownLatch(1);

​              CountDownLatch doneSignal = new CountDownLatch(SIZE);

​              ExecutorService exec = Executors.newCachedThreadPool();

​              for(int i = 0; i < SIZE; i++)

​                     exec.execute(new Entrance(i, doneSignal, stopSignal));

​                           TimeUnit.SECONDS.sleep(2);

​                           stopSignal.countDown();

​                           doneSignal.await();

​              exec.shutdown();

​              print("Total: " + Entrance.getTotalCount());

​              print("Sum of Entrances: " + Entrance.sumEntrances());

​       }

}

 

 

abstract class DelayedGreenhouseTask implements Delayed, Runnable {

​       protected long delayTime;        public long trigger;     public DelayedGreenhouseTask() {

​              delayTime = 0;

​              trigger = System.nanoTime();

​       }

​       public DelayedGreenhouseTask(long d) { 

​              delayTime = d; 

​              trigger = System.nanoTime() + 

​                     NANOSECONDS.convert(delayTime, MILLISECONDS);

​       }

​       public long getDelay(TimeUnit unit) {

​              return unit.convert(

​                     trigger - System.nanoTime(), NANOSECONDS);

​       }

​       public int compareTo(Delayed d) {

​              DelayedGreenhouseTask that = (DelayedGreenhouseTask)d;

​              if(trigger < that.trigger) return -1;

​              if(trigger > that.trigger) return 1;

​              return 0;

​       }

​             abstract public DelayedGreenhouseTask create(long d);

​       abstract public void run(); 

}

 

class GreenhouseController33 {

​       private volatile boolean light = false;

​       private volatile boolean water = false;

​       private String thermostat = "Day";

​       DelayQueue<DelayedGreenhouseTask> tasks = new DelayQueue<DelayedGreenhouseTask>();

​       public synchronized String getThermostat()  {

​              return thermostat;

​       }

​       public synchronized void setThermostat(String value) {

​              thermostat = value;

​       }

​       class LightOn33 extends DelayedGreenhouseTask {

​              public LightOn33() {

​                     super();

​              }

​              public LightOn33(long delayTime) {

​                     super(delayTime);

​              }

​              public LightOn33 create(long d) {                   return new LightOn33(d);

​              }

​              public void run() { 

​                     if(!light) {

​                            System.out.println("Turning on lights");

​                            light = true;

​                     }

​              }

​       }

​       class LightOff33 extends DelayedGreenhouseTask {

​              public LightOff33() {

​                     super();

​              }

​              public LightOff33(long delayTime) {

​                     super(delayTime);

​              }

​              public LightOff33 create(long d) { 

​                     return new LightOff33(d);

​              }

​              public void run() { 

​                     if(light) {

​                            System.out.println("Turning off lights");

​                            light = false;

​                     }

​              }

​       }

​       class WaterOn33 extends DelayedGreenhouseTask {

​              public WaterOn33() {

​                     super();

​              }

​              public WaterOn33(long delayTime) {

​                     super(delayTime);

​              }

​              public WaterOn33 create(long d) {                 return new WaterOn33(d);

​              }

​              public void run() {

​                                         System.out.println("Turning greenhouse water on");

​                     water = true;

​              }

​       }

​       class WaterOff33 extends DelayedGreenhouseTask {

​              public WaterOff33() {

​                     super();

​              }

​              public WaterOff33(long delayTime) {

​                     super(delayTime);

​              }

​              public WaterOff33 create(long d) { 

​                     return new WaterOff33(d);

​              }

​              public void run() {

​                                         System.out.println("Turning greenhouse water off");

​                     water = false;

​              }

​       }

​       class ThermostatNight33 extends DelayedGreenhouseTask {

​              public ThermostatNight33() {

​                     super();

​              }

​              public ThermostatNight33(long delayTime) {

​                     super(delayTime);

​              }

​              public ThermostatNight33 create(long d) { 

​                     return new ThermostatNight33(d);

​              }

​              public void run() {

​                                         System.out.println("Thermostat to night setting");

​                     setThermostat("Night");

​              }

​       }

​       class ThermostatDay33 extends DelayedGreenhouseTask {

​              public ThermostatDay33() {

​                     super();

​              }

​              public ThermostatDay33(long delayTime) {

​                     super(delayTime);

​              }

​              public ThermostatDay33 create(long d) { 

​                     return new ThermostatDay33(d);

​              }

​              public void run() {

​                                         System.out.println("Thermostat to day setting");

​                     setThermostat("Day");

​              }

​       }

​       class Bell33 extends DelayedGreenhouseTask {

​              public Bell33() {

​                     super();

​              }

​              public Bell33(long delayTime) {

​                     super(delayTime);

​              }

​              public Bell33 create(long d) {

​                     return new Bell33(d);

​              }

​              public void run() { System.out.println("Bing!"); }

​       }

​             static class DataPoint33 {

​              final Calendar time;

​              final float temperature;

​              final float humidity;

​              public DataPoint33(Calendar d, float temp, float hum) {

​                     time = d;

​                     temperature = temp;

​                     humidity = hum;

​              }

​              public String toString() {

​                     return time.getTime() + 

​                            String.format(

​                                   " temperature: %1$.1f humidity: %2$.2f",

​                                   temperature, humidity);

​              }

​       }

​       private Calendar lastTime = Calendar.getInstance();

​       {            lastTime.set(Calendar.MINUTE, 30);

​              lastTime.set(Calendar.SECOND, 00);

​       }

​       private float lastTemp = 65.0f;

​       private int tempDirection = +1;

​       private float lastHumidity = 50.0f;

​       private int humidityDirection = +1;

​       private Random rand = new Random(47);

​       List<DataPoint33> data = Collections.synchronizedList(

​              new ArrayList<DataPoint33>());

​       class CollectData33 extends DelayedGreenhouseTask {

​              public CollectData33() {

​                     super();

​              }

​              public CollectData33(long delayTime) {

​                     super(delayTime);

​              }

​              public CollectData33 create(long d) {

​                     return new CollectData33(d);

​              }

​              public void run() {

​                     System.out.println("Collecting data");

​                     synchronized(GreenhouseController33.this) {

​                                                       lastTime.set(Calendar.MINUTE, 

​                                   lastTime.get(Calendar.MINUTE) + 30);

​                                                       if(rand.nextInt(5) == 4)

​                                   tempDirection = -tempDirection;

​                                                       lastTemp = lastTemp + 

​                                   tempDirection * (1.0f + rand.nextFloat());

​                            if(rand.nextInt(5) == 4) 

​                                   humidityDirection = -humidityDirection;

​                            lastHumidity = lastHumidity +

​                                   humidityDirection * rand.nextFloat();

​                                                                                                             data.add(new DataPoint33((Calendar)lastTime.clone(),

​                                   lastTemp, lastHumidity));

​                     }

​              }

​       }

​       public class StopController extends DelayedGreenhouseTask {

​              private ExecutorService exec;

​              public StopController(long delay, ExecutorService e) {

​                     super(delay);

​                     exec = e;

​              }

​              public StopController create(long delay) {

​                     return new StopController(delay, Executors.newCachedThreadPool());

​              }

​              public void run() {

​                     System.out.println("Calling shutdownNow()");

​                     exec.shutdownNow();

​                                         new Thread() {

​                            public void run() {

​                                   for(DataPoint33 d : data)

​                                          System.out.println(d);

​                            }

​                     }.start();

​              }

​       }

​       public static class GreenhouseGo implements Runnable {

​              private DelayQueue<DelayedGreenhouseTask> q;

​              public GreenhouseGo(DelayQueue<DelayedGreenhouseTask> q) {

​                     this.q = q;

​              }

​              public void run() {

​                                         try {

​                            while(!Thread.interrupted()) 

​                                   q.take().run();                     } catch(InterruptedException e) {

​                                                }

​                     System.out.println("Finished GreenhouseGo");

​              }

​       }

}

 

public class GreenhouseScheduler33 {

​       public static void repeat(

​       GreenhouseController33 c, DelayedGreenhouseTask task, long interval, long duration) 

​              throws Exception {

​              if(interval <= duration) {

​                     for(int i = 0; i < duration                          DelayedGreenhouseTask t = task.create(interval * (i + 1));

​                            c.tasks.put(t);

​                     }

​              }

​       }

​       public static void main(String[] args) throws Exception {

​              ExecutorService exec = Executors.newCachedThreadPool();

​              GreenhouseController33 ghc = new GreenhouseController33();

​              repeat(ghc, ghc.new Bell33(), 1000, 4000);

​              repeat(ghc, ghc.new ThermostatNight33(), 2000, 4000);

​              repeat(ghc, ghc.new LightOn33(), 200, 4000);

​              repeat(ghc, ghc.new LightOff33(), 400, 4000);

​              repeat(ghc, ghc.new WaterOn33(), 600, 4000);

​              repeat(ghc, ghc.new WaterOff33(), 800, 4000);

​              repeat(ghc, ghc.new ThermostatDay33(), 1400, 4000);

​              repeat(ghc, ghc.new CollectData33(), 500, 4000);

​              ghc.tasks.put(ghc.new StopController(5000, exec));

​              exec.execute(new GreenhouseController33.GreenhouseGo(ghc.tasks));

​       }

}

class ExchangerProducer34<T> implements Runnable {

​       private Generator<T> generator;

​       private Exchanger<List<T>> exchanger;

​       private List<T> holder;

​       ExchangerProducer34(Exchanger<List<T>> exchg, Generator<T> gen, List<T> holder) {

​              exchanger = exchg;

​              generator = gen;

​              this.holder = holder;

​       }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            for(int i = 0; i < ExchangerDemo34.size; i++)

​                                   holder.add(generator.next());

​                                                       holder = exchanger.exchange(holder);

​                     }

​              } catch(InterruptedException e) {

​                                  }

​       }

}

 

class ExchangerConsumer34<T> implements Runnable {

​       private Exchanger<List<T>> exchanger;

​       private List<T> holder;

​       private volatile T value;

​       ExchangerConsumer34(Exchanger<List<T>> ex, List<T> holder) {

​              exchanger = ex;

​              this.holder = holder;

​       }

​       public void run() {

​              try {

​                     while(!Thread.interrupted()) {

​                            holder = exchanger.exchange(holder);

​                            for(T x : holder) {

​                                   value = x;                                 holder.remove(x);                            }

​                     }

​              } catch(InterruptedException e) {

​                                  }

​              System.out.println("Final value: " + value);

​       }

}

 

public class ExchangerDemo34 {

​       static int size = 10;

​       static int delay = 5;     public static void main(String[] args) throws Exception { 

​              if(args.length > 0) size = new Integer(args[0]);

​              if(args.length > 1) delay = new Integer(args[1]);

​              ExecutorService exec = Executors.newCachedThreadPool();

​              Exchanger<List<XCTest34>> xc = new Exchanger<List<XCTest34>>();

​              List<XCTest34>

​                     producerList = new CopyOnWriteArrayList<XCTest34>(),

​                     consumerList = new CopyOnWriteArrayList<XCTest34>();

​             exec.execute(new ExchangerProducer34<XCTest34>(xc, BasicGenerator.create(XCTest34.class), producerList));

​              exec.execute(new ExchangerConsumer34<XCTest34>(xc, consumerList));

​              TimeUnit.SECONDS.sleep(delay);

​              exec.shutdownNow();

​       }

}