---
title: JS
date: 2019-10-04 10:00:00
tags: Javascript
---



# 2016年3月2日

## javascript

### 数据结构

- 数据：是指所有能输入计算机并能被计算机系统和程序识别、存储、加工和处理的符号的总称。
- 数据元素：数据的基本单位，在计算机程序中通常把数据元素作为一个整体来存储和处理。有时一个数据元素可由若干个数据项组成。
- 数据项：是数据不可分割的，具有独立含义的最小数据单位。

**算法**：

即对数据施加的操作。数据的运算定义在数据的逻辑结构上，每种逻辑结构都有一个运算的集合。最常用的检索、插入、删除、更新、排序等运算实际上只是在抽象的数据上所施加的一系列抽象的操作。



# 2016年3月3日

## javascript

### 算法与数据结构

**JavaScript Array 对象**

| 方法             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| concat()         | 连接两个或更多的数组，并返回结果。                           |
| join()           | 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 |
| pop()            | 删除并返回数组的最后一个元素                                 |
| push()           | 向数组的末尾添加一个或更多元素，并返回新的长度。             |
| reverse()        | 颠倒数组中元素的顺序。                                       |
| shift()          | 删除并返回数组的第一个元素                                   |
| slice()          | 从某个已有的数组返回选定的元素                               |
| sort()           | 对数组的元素进行排序                                         |
| splice()         | 删除元素，并向数组添加新元素。                               |
| toSource()       | 返回该对象的源代码。                                         |
| toString()       | 把数组转换为字符串，并返回结果。                             |
| toLocaleString() | 把数组转换为本地数组，并返回结果。                           |
| unshift()        | 向数组的开头添加一个或更多元素，并返回新的长度。             |
| valueOf()        | 返回数组对象的原始值                                         |

**push()** 遇到数组参数时，把整个数组参数作为一个元素；而 **concat()** 则是拆开数组参数，一个元素一个元素地加进去。 **push()** 直接改变当前数组；**concat()** 不改变当前数组。

```js
var arr = new Array(3)
arr[0] = "George"
arr[1] = "John"
arr[2] = "Thomas"


//push()
document.write(arr + "<br />")
document.write(arr.push([12,324,345]) + "<br />")
document.write(arr[3])
//George,John,Thomas
//4
//1,2,3,4

//concat()

brr=arr.concat([1,2,3]);
document.write(brr[3])
//1
```

```js
var d; // 声明变量。 
d = new Date(); // 创建 Date 对象。 
document.write(d.toLocaleString()+"<br/>"); // 转换为当前区域,返回转换的日期。

document.write(d.toString()); // 返回转换的日期。

结果：
2016/3/4 上午10:28:51

Fri Mar 04 2016 10:28:51 GMT+0800 (中国标准时间)
```

**toLocaleString()**方法返回一个 String 对象 ,这个对象中包含了用当前区域设置的默认格式表示的日期。 

**toString()**返回值与没有参数的 join() 方法返回的字符串相同。





# 2016年3月5日

## javascript

- parseInt(string, radix) 函数

**radix**： 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。

函数可解析一个字符串，并返回一个十进制整数。

- 进制转换

```javascript
//十进制转其他  
var x=110;  
alert(x);  
alert(x.toString(8));  
alert(x.toString(32));  
alert(x.toString(16));  
//其他转十进制  
var x='110';  
alert(parseInt(x,2));  
alert(parseInt(x,8));  
alert(parseInt(x,16));  
//其他转其他  
//先用parseInt转成十进制再用toString转到目标进制  
alert(String.fromCharCode(parseInt(141,8)))//"a"
alert(parseInt('ff',16).toString(2));//"11111111"
```

## nodejs

在ecmascript部分node和js其实是一样的，比如数据类型的定义，语法结构，内置对象

在js中的顶层对象:  window

在node中的顶层对象:  global

> 注意：在node中也没有什么window

一个文件就是一个模块

每个模块都有自己的作用域

我们使用var来申明的一个变量，他并不是全局的，而是属于当前模块下

**__filename**:当前文件被解析过后的绝对路径;

**require('模块')**:模块加载;

模块加载机制：

- 路径
  - 绝对路径
  - 相对路径
- 查找方式
  1. 首先按照加载的模块的文件名称进行查找
  2. 如果没有找到，则会在模块文件名称后加上.js的后缀，进行查找
  3. 如果还没有找到，则会在文件名称后加上.json的后缀，进行查找
  4. 如果还没有，则会在文件名称后加上.node的后缀，进行查找

> 文件名称 -> .js -> .json -> .node
>
> 

# 2016年3月6日

## nodejs

在一个模块中通过var定义的变量，其作用域范围是当前模块，外部不能够直接的访问
如果我们想一个模块能够访问另外一个模块中定义的变量，可以：

1. 把变量作为global对象的一个属性，但是这样的做法是推荐
2. 使用模块对象 module

**module** : 保存提供和当前模块有关的一些信息;
在这个**module**对象，有一个子对象：**exports** 对象
我们可以通过这个对象把一个模块中的局部变量对象进行提供访问

```js
<!-- 1.js -->
module.exports.a = a;


<!-- 2.js -->
var m5 = require('./5'); //这个方法的返回值，其实就被加载模块中的module.exports

console.log(module);

//{ a: 100 }
//
//module.exports = [1,2,3];   //exports 和 module.exports 的指向关系已经断开了,module.exports 给改写了，不是在这个对象上添加属性那样了
//。
```

**__filename **: 返回当前模块文件解析后的绝对路径，该属性其实并非全局的，而是模块作用域下的
**__dirname** : 返回当前模块文件所在目录解析后的绝对路径，该属性也不是全局的，而是模块作用域下的。



# 2016年3月7日

## nodejs

### process对象

- global
  - process对象
    - process对象是一个全局对象，可以在任何地方都能访问到他，通过这个对象提供的属性和方法，使我们可以对当前运行的程序的进程进行访问与控制。
    - argv
      - Array，一组包含命令行参数的数组
    - execPath
      - 开启当前进程的绝对路径
    - env
      - 返回用户环境信息。
    - version
      - 返回node版本信息
    - versions
      - 返回node以及node依赖包版本信息
    - pid
      - 当前进程的pid
    - title
      - 当前进程的显示名称（Getter、Setter）
    - arch
      - 返回当前CPU处理器架构 arm、ia32、x64
    - platform
      - 返回当前操作系统平台
    - cwd()
      - 返回当前进程的工作目录
    - chdir(directory)
      - 改变当前进程的工作目录
    - memoryUsage()
      - 返回node进程的内存使用情况，单位是byte
    - exit(code)
      - 退出
    - kill(pid)
      - 想进程发送信息
    - stdin
      - 标准输入流
    - stdout
      - 标准输出流

```js
//默认情况下，输入流是关闭的，要监听处理输入流数据，首先要开启输入流
process.stdin.resume();
 
//用于监听用户的输入数据

process.stdin.on('data', function(chunk) {
    console.log('用户输入了：' + chunk);
});
```

### Buffer类

**new Buffer(size); size [Number]** 创建一个Buffer对象，并为这个对象分配一个大小
当我们为一个Buffer对象分配空间大小以后，其长度是固定，不能更改。

> 内容会随机填充。

**new Buffer(str, [encoding])**:将字符串转化成指定二进制数字。

- str String类型 - 需要存入buffer的string字符串.
- encoding String类型 - 使用什么编码方式，参数可选.

**buf.length**

```js
var str2 = '妙味';
var bf2 = new Buffer(str2);
console.log(str2.length);//字符串长度
console.log(bf2.length);//字节长度
```

### 计算机网络

**TCP/IP协议**

**HTTP**(Hyper Text Transfer Protocol，超文本传输协议)是一种通信协议 ，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。

- 它是一个应用层协议，承载于TCP之上
- 由请求和响应构成，是一个标准的客户端服务器模型

TCP/IP协议族最重要的一点就是分层。按层次分别分为以下4层：

- 应用层

负责处理特定的应用程序，TCP/IP协议族内预存了各类通用的应用服务。
比如FTP、DNS等等，HTTP也在该层。

- 传输层

对上层应用层提供处于网络连接中两台计算机之间的数据传输。
该层有两个不同的协议：TCP和UDP。

- 网络层

处理网络上流动的数据包。
该层有协议有：IP、ICMP、IGMP。

- 数据链路层

处理连接网络的硬件部分。
包括操作系统、硬件设备驱动、网卡、光纤等。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/pic1.png)

**IP的作用：**

把各种数据包传送给对方。如果要保证确定传送到对方那里，则需要满足各类条件，其中最重要的两个条件是IP地址和MAC地址。

(1)IP地址：指明了节点被分配到的地址
(2)MAC地址：是指网卡所属的固定地址
(3)区别：IP地址可变换，但MAC地址基本上不会更改。

**URI与URL**

```js
格式：
http://user:pass@www.example.com:80/home/index.html?age=11#mask
http：协议方案名
user:pass：登录信息（认证）
www.example.com：服务器地址
80：端口号
/hone/index.html：文件路径
age=11：查询字符串
mask：片段标识符 
```

### 函数

```js
// 函数声明
function foo() {}

// 函数表达式
(function bar() {})

// 函数表达式
x = function hello() {}

if (x) {
   // 函数表达式
   function world() {}
}

// 函数声明
function a() {
   // 函数声明
   function b() {}
   if (0) {
      //函数表达式
      function c() {}
   }
}

//匿名函数
function () {}; 
```

> 参考：http://my.oschina.net/u/2331760/blog/468672?fromerr=uCBMydOv

**arguments.callee**

**arguments.callee **在哪一个函数中运行，它就代表哪个函数。 一般用在匿名函数中。
在匿名函数中有时会需要自己调用自己，但是由于是匿名函数，没有名子，无名可调。
这时就可以用arguments.callee来代替匿名的函数。

```js
(function(n){

    if(n > 1)    return n* arguments.calle(n-1);

    return n;

})(10);
//计算10的阶乘
//
function calleeDemo() {    
  alert(arguments.callee);
  return 10*10;
}

//function calleeDemo() {    
//alert(arguments.callee);
//return 10*10;
//}
```





# 2016年3月8日

## javascript

### 函数

**函数自执行**

**( function(){…} )()** 、 **( function (){…} () )**这两种立即执行函数的写法。

要在函数体后面加括号就能立即调用，则这个函数必须是**函数表达式**，不能是**函数声明**。

## nodejs

### Buffer

**Buffer类方法**

- 一个用户更好的操作二进制数据的类
  - 我们在操作文件或者网络数据的时候，其实操作的就是二进制数据流，Node为 我们提供了一个更加方便的去操作这个数据流的类Buffer，他是一个全局的类。
- **new Buffer(size)**
  - 分配一个新的 size 大小单位为8位字节的 buffer。
- **new Buffer(array)**
  - 分配一个新的 buffer 使用一个8位字节 array 数组.
- **new Buffer(string,[encoding])**
  - str String类型 - 需要存入buffer的string字符串.
  - encoding String类型 - 使用什么编码方式，参数可选.
- **buf.length**:buffer的bytes大小
- **buf[index]**:获取或者设置在指定index索引位置的8位字节内容。
- **buf.write(string,[offset],[length],[encoding])**:根据参数offset偏移量和指定的encoding编码方式，将参数string数据写入buffer。
  - **buf.write**(要写入的字符串, 从Buffer对象中的几位开始写入, 写入的字符串的长度, 写入的字符串的编码)
- **buf.toString([encoding],[start],[end])**:根据encoding参数（默认是"utf-8")返回一个解码的string类型；
- **buf.toJSON()**:返回一个JSON表示的Buffer实例。JSON.stringify将会默认调用字符串序列化这个Buffer实例。
- **buf.slice([start],[end])**:返回一个新的buffer，这个buffer将会和老的buffer引用相同的内存地址，注意：修改这个新的buffer实例slice切片，将会改变原来的buffer。
- **buffer.copy(targetBuffer,[targetStart],[sourceStart],[sourceEnd])**：进行buffer的拷贝。

```js
var bf=new Buffer("1234567");
var bf2=new Buffer(10);

console.log(bf);
console.log(bf2);

bf.copy(bf2,2,1,3);
console.log(bf);
console.log(bf2);

//结果：
//
<Buffer 31 32 33 34 35 36 37>
<Buffer 78 2f e5 4b b0 01 00 00 01 00>
<Buffer 31 32 33 34 35 36 37>
<Buffer 78 2f 32 33 b0 01 00 00 01 00>
```

**静态方法**

- **Buffer.isEncoding(encoding)**:如果给定的编码encoding是有效的，返回true，否则返回false。
- **Buffer.isBuffer(obj)**:测试这个obj是否一个Buffer。
- **Buffer.byteLength(string,[encoding])**:将会返回这个字符串真实byte长度。encoding编码默认是："utf8"。
- **Buffer.concat(list,[totalLength])**:返回一个保存着将传入buffer数组中所有buffer对象拼接在一起的buffer对象。







# 2016年3月9日

## nodejs

### fs模块

**fs.open(path, flags, [mode], callback)**

> 异步打开一个文件

- path : 要打开的文件的路径
- flags : 打开文件的方式 读/写
- mode : 设置文件的模式 读/写/执行  4/2/1(可以不填，意义不大）)
- callback : 回调
  - err : 文件打开失败的错误保存在err里面，如果成功err为null
  - fd : 被打开文件的标识，和定时器

```js
fs.open('1.txt', 'r', function(err, fd) {

    //console.log(err);
    //console.log(fd);

    if (err) {
        console.log( '文件打开失败' );
    } else {
        console.log( '文件打开成功' );
        console.log( fd );
    }

});

//结果：

null
3
文件打开成功
3



fs.open('1.txt', 'r', function(err, fd) {
    console.log(fd);
});

console.log("hello");

//结果
hello
3
//两个操作独自运行，打开文件需要一定时间，所以先输出"hello"。
```

**fs.openSync(path, flags, [mode])**

> fs.open() 的同步版.

**fs.read(fd, buffer, offset, length, position, callback)**

> 从指定的文档标识符fd读取文件数据。

- fd : 通过open方法成功打开一个文件返回的编号
- buffer : buffer对象
- offset : 新的内容添加到buffer中的起始位置
- length ： 添加到buffer中内容的长度
- position ：读取的文件中的起始位置
- callback : 回调
  - err
  - buffer的长度
  - buffer对象







# 2016年3月10日

## javascript

### json

```js
//JSON.parse 将 JSON 字符串转换成对象。
var jsontext = '{"firstname":"Jesper","surname":"Aaberg","phone":["555-0100","555-0120"]}'; 
var contact = JSON.parse(jsontext); 
document.write(contact.surname + ", " + contact.firstname); 
 
// Output: Aaberg, Jesper
// 

 
//JSON.stringify() 方法可以将任意的 JavaScript 值序列化成 JSON 字符串
//JSON.parse() 方法可以将一个 JSON 字符串解析成为一个 JavaScript 值。在解析过程中，还可以选择性的篡改某些属性的原始解析值。
//

var arr = ["a", "b", "c"]; 
var str = JSON.stringify(arr); 
document.write(str); 
document.write ("<br/>"); 
 
var newArr = JSON.parse(str); 
 
while (newArr.length > 0) { 
    document.write(newArr.pop() + "<br/>"); 
} 
 
 
// Output: 
// ["a","b","c"] 
// c 
// b 
// a
```

## Nodejs

- File System - 文件系统模块 -require("fs")
  - 该模块是核心模块，需要使用require导入后使用
  - 该模块提供了操作的一些API



- fs.readFile(filename, [options], callback)
  - fs.read()函数的同步版本。返回bytesRead的个数。



- fs.write(fd, buffer, offset, length[, position], callback)
  - fd : 打开的文件
  - buffer : 要写入的数据
  - offset : buffer对象中要写入的数据的起始位置
  - length : 要写入的buffer数据的长度
  - position : fd中的起始位置
  - callback : 回调

```js
fs.open('1.txt','r+',function(err,fd){
    console.log(err);
    console.log(fd);
    if (err) {
        console.log("打开文件失败。");
    }else{
        var bf=new Buffer("acdb");
        console.log(bf);
        fs.write(fd,bf,0,3,10,function(){
            console.log(arguments);//{ '0': null(错误信息), '1': 5(数据长度), '2': <Buffer 31 32 33 34 33 35 34 35>(buffer内容) }
            console.log("Bf更新后内容："+bf);
            
        });
    }
    
})
```

- fs.write(fd, data[, position[, encoding]],callback)
  - 把data写入到文档中，通过指定的fd。如果data不是buffer对象的实例则会把值强制转化成一个字符串。
- fs.writeSync(fd, buffer, offset, length[, position])
  - fs.write()同步版本
- fs.writeSync(fd, data[, position[, encoding]])
  - fs.write()同步版本
- fs.close(fd,callback)
  - 关闭一个打开的文件
- fs.closeSync(fd)
  - fs.close()的同步版本。
- fs.writeFile(filename, data, [options], callback)
  - 异步的将数据写入一个文件，如果文件不存在则新建，如果文件原先存在，会被替换。data可以是一个string，也可以是一个原生buffer。

```js
var fs=require("fs");
var rq=new Date();

var time=rq.getFullYear()+"年"+(rq.getMonth()+1)+"月"+rq.getDate()+"日";
var fileName=time+".markdown";
console.log(fileName);
fs.writeFile("1/"+fileName,"#"+time,function(){
    console.log(arguments);
});
```

- fs.writeFileSync(filename, data, [options])
  - fs.writeFile的同步版本。注意：没有callback，也不需要。
- fs.appendFile(filename, data, [options], callback)
  - 异步的将数据添加到一个文件的尾部，如果文件不存在，会创建一个新 文件。data可以是一个string，也可以是一个原生buffer。
- fs.appendFileSync(filename, data, [options])
  - fs.appendFile的同步版本 
- fs.readFile(filename, [options], callback)
  - 异步读取一个文件的全部内容
- fs.readSync(fd, buffer, offset, length, position)
  - fs.readFile同步版本 
- fs.exists(path, callback)
  - 检查指定路径的文件或者目录是否存在
- fs.existsSync(path)
  - fs.exists 函数的同步版。
- fs.unlink(path, callback)
  - 删除一个文件
- fs.unlinkSync(path)
  - fs.unlink()同步版本。





# 2016年3月11日

## Nodejs

### File System 文件系统模块

- fs.readFile(filename, [options], callback)
  - 异步读取一个文件的全部内容
- fs.readSync(fd, buffer, offset, length, position)
  - fs.readFile同步版本 

```js
fs.readFile("text.txt",function(err,data){
    if (err) {
        console.log("error");
    }else{
        console.log(data.toString());
    }
})
// Output: 
// hello
```

- fs.unlink(path, callback)
  - 删除一个文件
- fs.unlinkSync(path)
  - fs.unlink()同步版本。

```js
fs.unlink("2.txt",function(err){
    if (err) {
        console.log("error");
    }else{
        console.log("OK!");
    }
});
// Output: 
// OK!
```

- fs.rename(oldPath, newPath, callback)
  - 重命名

- fs.renameSync(oldPath, newPath)
  - 同步版本的rename()

```js
fs.rename("2.txt","2.new.txt",function(err){
    if (err) {
        console.log("error");
    }else{
        console.log("OK!");
    }
});

```

- fs.stat(path, callback)
  - 读取文件信息
- fs.statSync(path)
  - fs.stat()同步版本。

```js
fs.stat('2.txt',function(){
    console.log(arguments);
})

//Output:
/*{ '0': null,
  '1': 
   { dev: -1302886562,
     mode: 33206,
     nlink: 1,
     uid: 0,
     gid: 0,
     rdev: 0,
     blksize: undefined,
     ino: 22799473113575696,
     size: 15,
     blocks: undefined,
     atime: Fri Mar 11 2016 16:13:39 GMT+0800 (中国标准时间),
     mtime: Fri Mar 11 2016 16:13:39 GMT+0800 (中国标准时间),
     ctime: Fri Mar 11 2016 16:13:39 GMT+0800 (中国标准时间),
     birthtime: Fri Mar 11 2016 16:13:39 GMT+0800 (中国标准时间) } }
*/
```

- fs.watch(filename,[options],[listener])
  - 观察指定路径的改变，filename路径可以是文件或者目录。

```js
var fs = require('fs');

var filename = '2.new.txt';

fs.watch(filename, function(ev, fn) {
    console.log(ev);
    if (fn) {
        console.log(fn + ' 发生了改变');
    } else {
        console.log('...hah.');
    }

});
```

> 如果系统底层函数出于某些原因不可用，那么 fs.watch 也就无法工作。例如，监视网络文件系统(如 NFS, SMB 等)的文件或者目录，就时常不能稳定的工作，有时甚至完全不起作用。

- fs.mkdir(path, [mode], callback)
  - 创建文件夹
  - [mode]
    - 33206:文件
    - 16822文件夹

- fs.mkdirSync(path, [mode])
  - 同步版的 mkdir()
- fs.rmdir(path, callback)
  - 删除文件夹
- fs.rmdirSync(path)
  - fs.redir()的同步版

```js
fs.mkdir("./12",33206,function(){
    console.log(arguments);
});
/*fs.rmdir("./12",function(){
    console.log(arguments);
})*/
```



- fs.readdirSync(path)
  - 异步版的 readdir()。 读取 path 路径所在目录的内容。 回调函数 (callback) 接受两个参数 (err, files) 其中 files是一个存储目录中所包含的文件名称的数组，数组中不包括 '.' 和 '..'。



```js
var fs = require('fs');

fs.readdir('../FileSystem', function(err, fileList) {

    //console.log(fileList);

    fileList.forEach(function(f) {

        fs.stat(f, function(err, info) {
            //console.log(info);

           switch (info.mode) {
                case 16822:
                    console.log( '[文件夹] ' + f );
                    break;

                case 33206:
                    console.log( '[文件] ' + f );
                    break;

                default :
                    console.log( '[其他类型] ' + f );
                    break;
            }

        });

    });

})

```

## 字符编码

- Unicode:(统一码)是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。

- UTF-8:针对Unicode的可变长度字符编码，又称万国码。
  - 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 
  - 对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。

- ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，



# 2016年3月12日

## CSS3

### flexbox

#### Flex容器属性（flex container）

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/flex1.png) 

容器默认存在两根轴：水平的主轴**（main axis）**和垂直的交叉轴**（cross axis）**。主轴的开始位置（与边框的交叉点）叫做**main start**，结束位置叫做**main end**；交叉轴的开始位置叫做**cross start**，结束位置叫做**cross end**。
项目默认沿主轴排列。单个项目占据的主轴空间叫做**main size**，占据的交叉轴空间叫做**cross size**。

**flex容器属性**

- **flex-direction**

**flex-direction**属性决定主轴的方向（即项目的排列方向）。

```css
.box {
    flex-direction: row | row-reverse | column | column-reverse;
}
```

1. row（默认值）：主轴为水平方向，起点在左端。
2. row-reverse：主轴为水平方向，起点在右端。
3. column：主轴为垂直方向，起点在上沿。
4. column-reverse：主轴为垂直方向，起点在下沿。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/flex-direction.png)

- **flex-wrap**属性

```css
 .box{
  flex-wrap: nowrap | wrap | wrap-reverse;
}
```

1. nowrap（默认）：不换行。
2. wrap：换行，第一行在上方。
3. wrap-reverse：换行，第一行在下方。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/flex-wrap.jpg) 

- **flex-flow**

```js
.box {
  flex-flow: <flex-direction> || <flex-wrap>;
}
```

flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。

- **justify-content**

**justify-content**属性定义了项目在主轴上的对齐方式。

```js
.box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}
```

1. flex-start（默认值）：左对齐
2. flex-end：右对齐
3. center： 居中
4. space-between：两端对齐，项目之间的间隔都相等。
5. space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/justify-content.png)

- **align-items**

**align-items**属性定义项目在交叉轴上如何对齐。

```js
.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
```

1. flex-start：交叉轴的起点对齐。
2. flex-end：交叉轴的终点对齐。
3. center：交叉轴的中点对齐。
4. baseline: 项目的第一行文字的基线对齐。
5. stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/align-items.png)

- **align-content**

**align-content**属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

```js
.box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
```

1. flex-start：与交叉轴的起点对齐。
2. flex-end：与交叉轴的终点对齐。
3. center：与交叉轴的中点对齐。
4. space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
5. space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
6. stretch（默认值）：轴线占满整个交叉轴。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/align-content.png)

#### 项目属性

- order

```js
.item {
  order: <integer>;
}
```

**order**属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/order.png)

- **flex-grow**

**flex-grow**属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

```js
.item {
  flex-grow: <number>; /* default 0 */
}
```

如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/flex-grow.png)

- **flex-shrink**

**flex-shrink**属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 

```js
.item {
  flex-shrink: <number>; /* default 1 */
}
```

如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
负值对该属性无效。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/flex-shrink.jpg)

- **flex-basis**

**flex-basis**属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 

```js
.item {
  flex-basis: <length> | auto; /* default auto */
}
```

它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。

- **flex**

**flex**属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。

```js
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
```

- **align-self**

```js
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

**align-self**属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

```js
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/align-self.png)



# 2016年3月13日

## javascript

### 转义字符

| 转义字符 | 意义                                | ASCII码值（十进制） |
| :------: | ----------------------------------- | ------------------- |
|    \a    | 响铃(BEL)                           | 007                 |
|    \b    | 退格(BS) ，将当前位置移到前一列     | 008                 |
|    \f    | 换页(FF)，将当前位置移到下页开头    | 012                 |
|    \n    | 换行(LF) ，将当前位置移到下一行开头 | 010                 |
|    \r    | 回车(CR) ，将当前位置移到本行开头   | 013                 |
|    \t    | 水平制表(HT) （跳到下一个TAB位置）  | 009                 |
|    \v    | 垂直制表(VT)                        | 011                 |
|    \\    | 代表一个反斜线字符''\'              | 092                 |
|    \'    | 代表一个单引号（撇号）字符          | 039                 |
|    \"    | 代表一个双引号字符                  | 034                 |
|    \?    | 代表一个问号                        | 063                 |
|    \0    | 空字符(NULL)                        | 000                 |
|   \ddd   | 1到3位八进制数所代表的任意字符      | 三位八进制          |
|   \xhh   | 1到2位十六进制所代表的任意字符      | 二位十六进制        |

> 常用转义字符：http://tool.oschina.net/commons?type=2

> HTML、CSS特殊字符表： http://www.w3cplus.com/resources/HTML-special-character-sheets.html
> HTML 特殊符号编码对照表: http://tool.chinaz.com/Tools/HtmlChar.aspx

# 2016年3月14日

## nodejs

### File System

文件系统模块中的异步方法需要一个完成时的**回调函数**作为最后一个传入形参。
回调函数的构成由您调用的异步方法所决定，通常情况下回调函数的第一个形参为返回的错误信息(**err**)。 如果异步操作执行正确并返回，该错误形参则为**null**或者**undefined**。

### http

1. 用户通过浏览器发送一个http的请求到指定的主机
2. 服务器接收到该请求，对该请求进行分析和处理
3. 服务器处理完成以后，返回对应的数据到用户机器
4. 浏览器接收服务器返回的数据，并根据接收到的进行分析和处理

客户端    服务端

由客户端发送一个http请求到指定的服务端 -> 服务端接收并处理请求 -> 返回数据到客户端

```js
var http=require('http');
var server=http.createServer();

server.listen(8080);

console.log(server.address());

//Output
//{ address: '::', family: 'IPv6', port: 8080 }
```

```js
//加载一个http模块
var http = require('http');
//通过http模块下的createServer创建并返回一个web服务器对象
var server = http.createServer();

server.on('error', function(err){
    console.log(err);
});

server.on('listening', function() {
    console.log('listening...');
})

server.on('request', function(req, res) {
    console.log('有客户端请求了');

    //console.log(req);

    //res.write('hello');

    res.setHeader('miaov', 'leo');

    res.writeHead(200, 'miaov', {
        //'content-type' : 'text/plain'

        'content-type' : 'text/html;charset=utf-8'
    });

    res.write('<h1>hello</h1>');

    res.end();

})

server.listen(8080, 'localhost');

//console.log(server.address());


```

- var http=require('http');
- var server=http.createServer([requestListener])
  - 创建并返回一个HTTP服务器对象
  - requestListener：监听到客户端连接的回调函数
- server.listen([port,[hostname],[backlog],[callback]])
  - 监听客户端连接请求，只有当调用listen方法以后，服务器才开始工作
  - port：监听的端口
  - hostname：主机名（IP/域名）
  - backlog：连接等待队列的最大长度
  - callback：调用listen方法并成功开启监听以后，会触发一个listen事件，callback将作为该事件的执行函数。

- listening事件：当server调用listen方法并成功开始监听以后触发的事件。
- error事件：当有客户端发送请求道该主机和端口的请求的时候触发
  - 参数request：http.IncomingMessage的一个实例，通过他我们可以获取到这次请求的一些信息，比如信息，数据等。
  - 参数response：http:http.ServerResponse的一个实例，通过他我们可以向该请求的客户端输出返回的响应。



# 2016年3月15日

## nodejs

### http模块

```js
//加载一个http模块
var http = require('http');
//通过http模块下的createServer创建并返回一个web服务器对象
var server = http.createServer();

server.on('error', function(err){
    console.log(err);
});

server.on('listening', function() {
    console.log('listening...');
})

server.on('request', function(req, res) {
    
    console.log('有客户端请求了');

    //console.log(req);

    //res.write('hello');

    res.setHeader('miaov', 'leo');

    res.writeHead(200, 'miaov', {
        //'content-type' : 'text/plain'

        'content-type' : 'text/html;charset=utf-8'
    });

    res.write('<h1>hello</h1>');

    res.end();

})

server.listen(8080, 'localhost');

//console.log(server.address());


```

- 参数request对象 -http.IncomingMessage 
  - httpVersion:使用的http协议的版本
  - headers：请求头信息中的数据
  - url：请求的地址
  - method：请求方式
- 参数response对象 - http.ServerResponse 
  - write(chunk,[encoding]):发送一个数据块到响应正文中
  - end([chunk],[encoding]):当所有的正文和头信息发送完成以后调用该方法告诉服务器数据已经全部发送完成了，这个方法在每次完成信息发送以后必须调用，并且是最后调用。
  - statusCode:该属性用来设置返回的状态码
  - setHeader(name,value):设置返回头信息
  - writeHeader(statusCode,[reasonPhrase],[headers])
    - 这个方法只能在当前请求中使用一次，并且必须在response.end()之前调用

### 同步、异步、阻塞、非阻塞

**同步通信**是指：发送方和接收方通过一定机制，实现收发步调协调。如：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式

**异步通信**是指：发送方的发送不管接收方的接收状态，如：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。

**阻塞**和**非阻塞**就比较容易理解了，没有上面那么多场景，**阻塞**就是这个事情阻到这儿了，不能继续往下干事了，**非阻塞**就是这个事情不会阻碍你继续干后面的事情。

**阻塞**可以是实现同步的一种手段！例如两个东西需要同步，一旦出现不同步情况，我就阻塞快的一方，使双方达到同步。

 

**同步**是两个对象之间的关系，而**阻塞**是一个对象的状态。

# 2016年3月16日

## javascript

### 实参与形参

```js
function addNum(var para1,var para2){
var sum = para1+para2;
return sum;
}
```

形参指函数定义时候的参数，在这里就是para1和para2。实参是实际传送给函数的参数，在这里就是20和30。

### angularjs

- MVC
  - model
  - view 
  - controller
    - MV的桥梁
- service服务
  - $内部
  - $scope
  - $apply
  - $watch
  - $rootScope
  - $http
  - $timeout
  - $filter

- directive指令
  - ng内部
  - ng-app
  - ng-controller
  - ng-repeat
  - ng-click

​    

# 2016年3月17日

## javascript

### angularjs

- angularJs特性？
  - MVC模式
  - 模块系统
  - 指令系统
  - 依赖注入
  - 双向数据绑定
- angularJs的作用域
  - $scope
  - $rootScope
  - 依赖注入
  - 服务

```js 

function Aaa($scope ,$rootScope){//依赖注入，形参不能改
    $scope.name='hello world!!';
    $rootScope.txt="nihao";//全局变量，
}
function Bbb($scope){
    $scope.name='Bbb hello world!!';
}
```

```html
<div ng-controller='Aaa'>
    <p>{{name}}</p>
</div>
<div  ng-controller="Bbb">
    <span>{{txt}}</span>//会先在局部查找，然后在全局查找。
</div>
```

- angularJs的指令系统
  - ng-app
    - 初始化一个angularjs应用程序
  - ng-controller
    - 定义控制器
- angularJs的双向数据绑定
  - MVVM
  - $timeout
    - 有刷新功能
  - ng-click
    - click事件
  - ng-model
    - 绑定数据

```js
    function Aaa($scope,$timeout){
    $scope.name = 'hello';
    /*setTimeout(function(){
        $scope.name = 'hi';
    },2000);*/
    /*$timeout(function(){
        $scope.name = 'hi';
    },2000);*/
    
    $scope.show = function(){
        $scope.name = 'hi';
    };
    
}
```

```html 
<div ng-controller="Aaa" ng-click="show()">
    <p>{{name}}</p>
</div>
```

- 过滤器
  - currency

```html
<span>{{all.money*all.num|currency:'@'}}</span>
```

- $watch
  - 监听数据变化
  - 三个参数
    - 第三个为**true**时可以监听一个整体，否则是单个。

```js
$scope.$watch($scope.sum,function(newVal,oldVal){
        //console.log(newVal);
        //console.log(oldVal);
        
$scope.iphone.fre = newVal >= 100 ? 0 : 10;
        
});
```

# 2016年3月18日

## angularjs

模块写法：

```js
var m1 = angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
    $scope.name = 'hello';
}]);
m1.controller('Bbb',['$scope',function($scope){
    $scope.name = 'hi';
}]);
```

- angular.bind()

```js
function show(n1,n2){
    alert(n1);
    alert(n2);
    alert(this);
}

angular.bind(document,show,3)(4);//改this指向
```

- angular.copy()

```js
var a = {
    name : 'hello'
};
var b = {
    age : '20'
};

var c = angular.copy(a,b);   //a把所有值覆盖给了b,也拷贝了给C对象
```

- angular.extend();  

```js

var a = {
    name : 'hello'
};
var b = {
    age : '20'
};

var c = angular.extend(b,a); //对象继承

console.log(b);
//{age: "20", name: "hello"}//继承了a的属性方法。

console.log(c);
//{age: "20", name: "hello"}
//
console.log(a);
//{name: "hello"}
```

- angularJs的工具方法
  - angular.isArray
    - 判断是否数组
  - angular.isDate
    - 如果引用的是日期返回 true
  - angular.isDefined
    - 如果引用的已定义返回 true
  - angular.isUndefined
    - 如果引用的未定义返回 true
  - angular.isFunction
    - 如果引用的是函数返回 true
  - angular.isNumber
    - 如果引用的是数字返回 true
  - angular.isObject
    - 如果引用的是对象返回 true
  - angular.isString
    - 如果引用的是字符串返回 true
  - angular.isElement
    - 判断是否元素
  - angular.version
    - 返回版本信息
  - angular.equals
    - 判断是否相等。
  - angular.forEach
    - 循环，接受三个参数。
  - angular.fromJson/toJson
    - json与字符串的转换。
  - angular.identity/noop
    - 空函数，或者返回指定内容。防止程序出问题。
  - angular.lowercase/uppercase
    - 字符串全部大写或者小写。
  - angular.element
    - 选择元素，类似jQuery的选择器`angular.element === $`。
  - angular.bootstrap
    - 在javascript里动态初始化
  - angular.injector



# 2016年3月19日

## angularjs

- $scope
  - $scope.$watch
    - 监听程序变化
  - $scope.$apply
    - 监听数据变化，数据变化，会影响视图。
- angular.module
  - controller
  - run
- angularJs的过滤器
  - currency
  - number
  - lowercase/uppercase
  - json
  - limitTo
  - date
  - orderBy
  - filter

```js
//过滤器组合使用
m1.controller('Aaa',['$scope','$filter',function($scope,$filter){
    
    //$scope.name = '723894734.7489545';
    //$scope.name = 'hello';
    //$scope.name = {"name":"hello","age":"20"};
    //$scope.name = ['a','b','c'];
    $scope.name = '3748935795';
    
    /*$scope.name = [
        {color:"red",age:"20"},
        {color:"yellow",age:"30"},
        {color:"blue",age:"40"},
        {color:"green",age:"10"}
    ];*/
    
    //$scope.name = $filter('uppercase')('hello');
    //$scope.name = $filter('number')('236478234.3647348',1);
    //$scope.name = $filter('date')('236478234','hh');
    
    //$scope.name = 'hello';
    
    $scope.name = $filter('firstUpper')('hello');
    

}]);


//自定义过滤器
//

m1.filter('firstUpper',function(){
    return function(str,num){
        //console.log(num);
        return str.charAt(0).toUpperCase() + str.substring(1);
    }
});
```

- ng-repeat
- ng-app
  - 初始化angularjs这个库的指令
- ng-controller
  - 调用控制器，把数据与视图连接在一起
- ng-model
  - 
- ng-click
  - 点击事件

# 2016年3月20日

## angularjs

**ng-repeat 指令**

- 扩展部分
  - $index
    - 索引号
  - $first
    - 第一项返回true，其他都是false
  - $middle
    - 除了头尾，都返回true。
  - $last
    - 最后一项返回true。
  - $even
    - 奇数行返回true
  - $odd
    - 偶数行返回true
  - ng-repeat-start
  - ng-repeat-end

```js
var m1 = angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
    
    $scope.dataList = [
        'aaaaa' , 'bbbbb' , 'cccccc' , 'dddddd' , 'eeeeee'
    ];

}]);

```

```html
<div ng-repeat-start="data in dataList">{{data}}</div>
<p>{{data}}</p>
<div ng-repeat-end>{{data}}</div>
```

**事件指令**

- ng-click/dblclick
- ng-mousedown/up
- ng-mouseenter/leave
- ng-mousemove/over/out
- ng-keydown/up/press
- ng-focus/blur
- ng-submit
- ng-selected

```js
<input type="checkbox" ng-model="aaa">
<select>
    <option>11111</option>
    <option ng-selected="aaa">22222</option>
    <option>33333</option>
</select>
    
```

- ng-change
- ng-copy
  - 进行复制操作会触发这个事件 
- ng-cut
  - 进行剪切操作会触发这个事件 
- ng-paste
  - 进行粘贴操作会触发这个事件 

**angularJs的指令**

- ng-disabled
  - 服务 $interval，动态修改按钮的状态。
- ng-readonly
  - 针对文本可读状态， 对按钮没效果。
- ng-checked
- ng-value
- ng-bind
  - 只能嵌套一个
- ng-cloak
  - 控制display ，没解释完是none，解释完才显示 出来。
- ng-bind-template
  - 可以嵌套多个
- ng-bind-html
  - 不能解释标签，必须要添加插件
  - http://www.bootcdn.cn/angular.js/
- ng-non-bindable
  - 不让表达式去解释

**angularJs的样式指令**

- ng-class
- ng-style
- ng-href
- ng-src
- ng-attr-(suffix)
  - 一般的标签属性设置

```js
var m1 = angular.module('myApp',[]);
m1.controller('Aaa',['$scope',function($scope){
    $scope.text = 'hello';
    $scope.style = "{color:'red',background:'yellow'}";
    $scope.sClass = "{red:true,yellow:true}";
    $scope.url = "http://www.baidu.com";
}]);

```

```html 
<div ng-controller="Aaa">
    <div ng-class="{{sClass}}">{{text}}</div>
    <div ng-style="{{style}}">{{text}}</div>
    <a ng-href="{{url}}">aaaaaaa</a>
    <a ng-attr-href="{{url}}" ng-attr-title="{{text}}" ng-attr-class="" ng-attr-style="">aaaaaaa</a>
</div> 
```

- ng-init
- ng-include
  - 引入其他文件模板

```js
<div ng-controller="Aaa" ng-include="'temp.html'">
```

- ng-model
  - 双向数据绑定
  - ng-model-options
  - updateOn
    - 双向数据绑定延迟触发
- ng-controller
  - as
    - 构造函数的属性

**angularjs标签指令**

- < a >
- < select >
  - ng-options
  - for   in
- < textarea >
- < input >
- < form >
  - novalidate
    - 防止表单默认行为

**ngularJs的表单验证**

- $valid
  - 是否有效，有效返回true。可用于Email输入。
- $invalid
- $pristine
  - 是否修改过，是就返回true。
- $dirty
  - 初始值返回false
- $error
  - 打印认证信息
- 注意点
  - name的方式进行查找
  - 要写ng-model





# 2016年3月21日

## angularjs

**npm操作使用教程**

```
cd xxx  //访问某个文件夹

npm install angular//安装angularjs文件包

npm uninstall angular //删除angularjs文件包

使用npm help <command>可查看某条命令的详细帮助，例如npm help install。

输入 "npm -v" 来测试是否成功安装

npm install <Module Name>//使用 npm 命令安装模块

npm install express          # 本地安装
npm install express -g   # 全局安装

npm ls -g//使用以下命令来查看所有全局安装的模块

```

- **本地安装**
  1. 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。
  2. 可以通过 require() 来引入本地安装的包。

- **全局安装**

  1. 将安装包放在 /usr/local 下。

  2. 可以直接在命令行里使用。

  3. 不能通过 require() 来引入本地安装的包。
     接下来我们使用全局方式安装 express

     

# 2016年3月22日

## nginx

**反向代理**

我们有时候，用自己的计算机A想访问国外的某个网站B，但是访问不了，此时，有一台中间服务器C可以访问国外的网站B，那么，我们可以用自己的电脑访问服务器C，通过C来访问B这个网站。那么这个时候，服务器C称为代理服务器，这种访问方式叫做正向代理。正向代理有一个特点，就是我们明确知道要访问哪个网站。再如，当我们有一个服务器集中，并且服务器集群中的每台服务器的内容一样的时候，同样我们要直接从个人电脑访问到服务器集中的服务器的时候无法访问，且此时第三方服务器能访问集群，这个时候，我们通过第三方服务器访问服务器集群的内容，但是此时我们并不知道是哪一台服务器提供的内容，此时的代理方式称为反向代理。

**负载均衡**

当一台服务器的单位时间内的访问量越大的时候，服务器的压力会越大。当一台服务器压力大得超过自身的承受能力的时候，服务器会崩溃。为了避免服务器崩溃，让用户有更好地体验，我们通常通过负载均衡的方式来分担服务器的压力。那么什么是负载均衡呢？是这样，我们可以建立很多很多个服务器，这些服务器组成一个服务器集群，然后，当用户访问我们网站的时候，先访问一个中间服务器，再让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入该选择的服务器。这样，用户的每次访问，都会保证服务器集群中的每个服务器的压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况。





# 2016年3月23日

## css

### margin属性

- 垂直外边距合并

简单地说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。

**请注意**，如果不设置 div 的内上边距(**padding-top**)或上边框(**border-top**)，那么内部 div 的上外边距将与外部 div 的上外边距合并（叠加）。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/ct_css_margin_collapsing_example_1.gif)

当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上或下外边距也会发生合并。

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/ct_css_margin_collapsing_example_2.gif)

假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并：

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/ct_css_margin_collapsing_example_3.gif)

如果这个外边距遇到另一个元素的外边距，它还会发生合并:

![](C:/Users/Administrator/Desktop/My-study-records-master/2016/3/img/ct_css_margin_collapsing_example_4.gif)

> 只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。
> http://www.w3school.com.cn/css/css_margin_collapsing.asp

### html与body

宽高的百分比是基于包含它的块级对象的百分比宽高。
父元素没高度，子元素100%的父元素高度也是0

当body里只有一个relative元素的时候，只有同时设置html和body的100%高度才能使这个元素的宽高填充。

一旦设置了html标签height:100%;则无论哪个浏览器下body都支持height:100%;了，而body内部的容器也可以支持height:100%;了。

### angularjs

- ng-app 指令初始化一个 AngularJS 应用程序。
  - ng-app 指令告诉 AngularJS，哪个元素是 AngularJS 应用程序 的"所有者"，也是angularjs程序的开始。
- ng-model 指令读取元素的值（比如输入域的值），然后绑定到应用程序。
  - ng-model 指令把输入域的值绑定到应用程序变量 name。
- ng-bind 指令把应用程序数据绑定到 HTML 视图。
  - ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。
- ng-init 指令初始化 AngularJS 应用程序变量。
- AngularJS 属性以**ng-** 开头，但是您可以使用**data-ng-** 来让网页对 HTML5有效。

```html
<div ng-app="">
    <!-- ng-model指令读取用户输入信息，然后传递给变量name -->
    <p>名字 : <input type="text" ng-model="name"></p>
    <h1>Hello {{name}}</h1>
</div>


<div ng-app="" ng-init="firstName='John'">
    <!-- ng-bind指令是控制标签的innerHTMl，内容为参数值。 -->
    <p>姓名为 <span ng-bind="firstName"></span></p>
    <p>姓名为 <span data-ng-bind="firstName"></span></p>
    <p>姓名为 <span>{{name}}</span></p>
</div>
```

```html
<!-- ng-app定义了一个angularjs应用，在哪个标签插入，应用就在哪开始。 -->
<!-- ng-controller确定了使用模块下哪个控制器 -->
<div ng-app="myApp" ng-controller="myCtrl">


名: <input type="text" ng-model="firstName"><br>
姓: <input type="text" ng-model="lastName"><br>
<br>
姓名: {{firstName + " " + lastName}}

</div>

<script>
var app = angular.module('myApp', []);//定义一个模块，
app.controller('myCtrl', function($scope) {//调用模块的方法
    $scope.firstName= "John";
    $scope.lastName= "Doe";
});
</script>
```

**自定义的指令**

使用驼峰法来命名一个指令，**runoobDirective** , 但在使用它时需要以 - 分割, **runoob-directive**。

调用方式：

- 元素名

```html
<div ng-app="myApp">
    元素名：<hi-boy></hi-boy>
    <script type="text/javascript">
        var app=angular.module('myApp',[]);
        app.directive("hiBoy",function(){
            return {
                template:"<span>hello boy </span>"
            };
        });
    </script>
</div>
```

- 属性 

```html
<div ng-app="myApp">
    属性：<div hi-boy></div>
    <script type="text/javascript">
        var app=angular.module('myApp',[]);
        app.directive("hiBoy",function(){
            return {
                replace:true,
                restrict:'M',
                template:"<span>hello boy </span>"
            };
        });
    </script>
</div>
```

- 类名

```html
<div ng-app="myApp">
    属性：<div class="hi-boy"></div>
    <script type="text/javascript">
        var app=angular.module('myApp',[]);
        app.directive("hiBoy",function(){
            return {
                // 必须设置 restrict 的值为 "C" 才能通过类名来调用指令。
                restrict:'C',
                template:"<span>hello boy </span>"
            };
        });
    </script>
</div>
```

- 注释

```html
<div ng-app="myApp">
    注释：<!-- directive:hi-boy -->
    <script type="text/javascript">
        var app=angular.module('myApp',[]);
        app.directive("hiBoy",function(){
            return {
                replace:true,//需要在该实例添加 replace 属性， 否则评论是不可见的。
                restrict:'M',//须设置 restrict 的值为 "M" 才能通过注释来调用指令。
                template:"<span>hello boy </span>"
            };
        });
    </script>
</div>
```

restrict 值可以是以下几种:

- E 只限元素名使用
- A 只限属性使用
- C 只限类名使用
- M 只限注释使用

restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。

# 2016年3月24日

## angularjs

- ng-model 指令

ng-model 指令可以将输入域的值与 AngularJS 创建的变量绑定。

```html
<form ng-app="" name="myForm">
    Email:
    <input type="email" name="myAddress" ng-model="text">
    <span ng-show="myForm.myAddress.$error.email">不是一个合法的邮箱地址</span>
</form>
```

> 提示信息会在 ng-show 属性返回 true 的情况下显示。

**应用状态**
ng-model 指令可以为应用数据提供状态值(**invalid**, **dirty**, **touched**, **error**):

```html 
<form ng-app="" name="myForm" ng-init="myText = 'test@runoob.com'">

Email:
<input type="email" name="myAddress" ng-model="myText" required>
<p>编辑邮箱地址，查看状态的改变。</p>
<h1>状态</h1>
<p>Valid: {{myForm.myAddress.$valid}} (如果输入的值是合法的则为 true)。</p>
<p>Dirty: {{myForm.myAddress.$dirty}} (如果值改变则为 true)。</p>
<p>Touched: {{myForm.myAddress.$touched}} (如果通过触屏点击则为 true)。</p>

</form>
```

**CSS 类**

ng-model 指令基于它们的状态为 HTML 元素提供了 CSS 类：

```html
<style>
input.ng-invalid {
    background-color: lightblue;
}
</style>
<body>

<form ng-app="" name="myForm">
    输入你的名字:
    <input name="myAddress" ng-model="text" required>
</form>
```

ng-model 指令根据表单域的状态添加/移除以下类：

- ng-empty
  - 值为空
- ng-not-empty
  - 值不为空
- ng-touched
  - 控件已失去焦点
- ng-untouched
  - 控件未失去焦点
- ng-valid
  - 有效值
- ng-invalid
  - 无效值
- ng-dirty
  - 值改变
- ng-pending
  - 任何为满足$asyncValidators的情况
- ng-pristine
  - 控件为初始状态

**AngularJS 应用组成**

- View(视图), 即 HTML。
- Model(模型), 当前视图中可用的数据。
- Controller(控制器), 即 JavaScript 函数，可以添加或修改属性。

**过滤器**

| 过滤器    | 描述                     |
| --------- | ------------------------ |
| currency  | 格式化数字为货币格式。   |
| filter    | 从数组项中选择一个子集。 |
| lowercase | 格式化字符串为小写。     |
| orderBy   | 根据某个表达式排列数组。 |
| uppercase | 格式化字符串为大写。     |

过滤器可以通过一个管道字符（|）和一个过滤器添加到表达式中。.

**uppercase**过滤器将字符串格式化为大写：

```html 
<div ng-app="myApp" ng-controller="personCtrl">

<p>姓名为 {{ lastName | uppercase }}</p>

</div>

```

**过滤输入**

输入过滤器可以通过一个管道字符（|）和一个过滤器添加到指令中，该过滤器后跟一个冒号和一个模型名称。
**filter** 过滤器从数组中选择一个子集：

```html5
<div ng-app="myApp" ng-controller="namesCtrl">

<p><input type="text" ng-model="test"></p>

<ul>
  <li ng-repeat="x in names | filter:test | orderBy:'country'">
    {{ (x.name | uppercase) + ', ' + x.country }}
  </li>
</ul>

</div>

```



# 2016年3月25日

## angularjs

**AngularJS 服务(Service)**

在 AngularJS 中，服务是一个函数或对象，可在你的 AngularJS 应用中使用。

- $location 服务，它可以返回当前页面的 URL 地址。

```js
var app = angular.module('myApp', []);
app.controller('customersCtrl', function($scope, $location) {
    $scope.myUrl = $location.absUrl();
});
```

- $http 是 AngularJS 应用中最常用的服务。服务向服务器发送请求，应用响应服务器传送过来的数据。

```js
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope, $http) {
    $http.get("welcome.htm").then(function (response) {
        $scope.myWelcome = response.data;
    });
});
```

## html

**无内容元素（Void elements）**

无内容元素是一种不能包含任何内容的特殊元素。而其他元素，比如 <div>，则既可以不包含任何内容，又可以包含另一个元素或者文字。

比较常见的无内容元素有：

- < br>
- < hr>
- < img>
- < input>
- < link> 
- < meta>

不太常见的无内容元素有：

- < area>
- < base>
- < col>
- < command>
- < embed>
- < keygen>
- < param>
- < source>
- < track>
- < wbr>

此类标签应由下列部分组成，顺序须与下表保持一致：

- 一个 “<” 字符。
- 标签名。
- 此项可选，一个或多个属性，每一个属性的前面必须有一个或多个空格。
- 此项可选，一个或多个空格。
- 此项可选，一个 “/” 字符，此项只能在无内容元素中出现。
- 一个 “>” 字符。

倒数第二部分的 “/” 字符是可选的，而且没有任何实际含义。所以 < br> 和 < br /> 其实没有实质区别。

> http://blog.jobbole.com/61514/

**AngularJS Select(选择框)**

使用 ng-option 指令来创建一个下拉列表，列表项通过对象和数组循环输出

```html
<div ng-app="myApp" ng-controller="myCtrl">

<select ng-model="selectedName" ng-options="x for x in names">
</select>

</div>

<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope) {
    $scope.names = ["Google", "Runoob", "Taobao"];
});
</script>
```

也可以使用ng-repeat 指令：

```html 
<select>
<option ng-repeat="x in names" value="{{x.names}}">{{x}}</option>
</select> 
```

> option标签的value值是发给服务器的值。

**ng-repeat**指令是通过数组来循环 HTML 代码来创建下拉列表，但 **ng-options** 指令更适合创建下拉列表，它有以下优势：
使用 **ng-options** 的选项的一个对象， **ng-repeat** 是一个字符串。

# 2016年3月28日

## angularjs

使用 angular 显示表格

```html 
<div ng-app="myApp" ng-controller="customersCtrl"> 

<table>
  <tr ng-repeat="x in names">
    <td>{{ x.Name }}</td>
    <td>{{ x.Country }}</td>
  </tr>
</table>

</div>
<script>
var app = angular.module('myApp', []);
app.controller('customersCtrl', function($scope, $http) {
    $http.get("http://www.runoob.com/try/angularjs/data/Customers_JSON.php")
    .success(function (response) {$scope.names = response.records;});
});
</script>
```

可以使用 orderBy 过滤器: 

```html 
<table>
  <tr ng-repeat="x in names | orderBy : 'Country'">
    <td>{{ x.Name }}</td>
    <td>{{ x.Country }}</td>
  </tr>
</table>
```

可以在 < td> 中添加 $index: 

```html 
<table>
  <tr ng-repeat="x in names">
    <td>{{ $index + 1 }}</td>
    <td>{{ x.Name }}</td>
    <td>{{ x.Country }}</td>
  </tr>
</table>
```

使用 $even 和 $odd

```html 
<table>
<tr ng-repeat="x in names">
<td ng-if="$odd" style="background-color:#f1f1f1">{{ x.Name }}</td>
<td ng-if="$even">{{ x.Name }}</td>
<td ng-if="$odd" style="background-color:#f1f1f1">{{ x.Country }}</td>
<td ng-if="$even">{{ x.Country }}</td>
</tr>
</table>
```

**跨域 HTTP 请求**

指定某域名`（http://client.runoob.com）`跨域访问，则只需在`http://server.runoob.com/server.php`文件头部添加如下代码：

```php 
header('Access-Control-Allow-Origin:http://client.runoob.com');
```

> 参考：http://www.runoob.com/w3cnote/php-ajax-cross-border.html 。

**ng-disabled** 指令绑定应用程序数据 **mySwitch** 到 HTML 的 disabled 属性。
**ng-model** 指令绑定 **mySwitch** 到 HTML input checkbox 元素的内容（value）。

**AngularJS 事件**

- ng-click 指令定义了 AngularJS 点击事件。
- ng-hide 指令用于设置应用部分是否可见。
- ng-hide="true" 设置 HTML 元素不可见。
- ng-hide="false" 设置 HTML 元素可见。

```html 
<div ng-app="myApp" ng-controller="personCtrl">

<button ng-click="toggle()">>隐藏/显示</button>

<p ng-hide="myVar">
名: <input type="text" ng-model="firstName"><br>
姓名: <input type="text" ng-model="lastName"><br>
<br>
Full Name: {{firstName + " " + lastName}}
</p>

</div>

<script>
var app = angular.module('myApp', []);
app.controller('personCtrl', function($scope) {
    $scope.firstName = "John",
    $scope.lastName = "Doe"
    $scope.myVar = false;
    $scope.toggle = function() {
        $scope.myVar = !$scope.myVar;
    };
});
</script>
```

**类似**

- ng-show 指令可用于设置应用中的一部分是否可见 。
- ng-show="false" 可以设置 HTML 元素 不可见。
- ng-show="true" 可以以设置 HTML 元素可见。



[TOC]

# 2016年3月29日

## angularjs

**AngularJS 模块**

- 创建模块

你可以通过 AngularJS 的 angular.module 函数来创建模块： 

```html 
<div ng-app="myApp">...</div>

<script>

var app = angular.module("myApp", []); 

</script>
```

**myApp**参数对应执行应用的 HTML 元素。
现在你可以在 AngularJS 应用中添加控制器、指令、过滤器等。

- 添加控制器

你可以使用 ng-controller 指令来添加**应用**的控制器: 

```html 
<div ng-app="myApp" ng-controller="myCtrl">
{{ firstName + " " + lastName }}
</div>

<script>

var app = angular.module("myApp", []);//应用模块的定义程序

app.controller("myCtrl", function($scope) {//控制器
    $scope.firstName = "John";
    $scope.lastName = "Doe";
});

</script>
```

**AngularJS 表单**

```html
<div ng-app="myApp" ng-controller="formCtrl">
  <form novalidate>
    First Name:<br>
    <input type="text" ng-model="user.firstName"><br>
    Last Name:<br>
    <input type="text" ng-model="user.lastName">
    <br><br>
    <button ng-click="reset()">RESET</button>
  </form>
  <p>form = {{user}}</p>
  <p>master = {{master}}</p>
</div>

<script>
var app = angular.module('myApp', []);
app.controller('formCtrl', function($scope) {
    $scope.master = {firstName: "John", lastName: "Doe"};
    $scope.reset = function() {
        $scope.user = angular.copy($scope.master);
    };
    $scope.reset();
});
</script>

```

> **novalidate** 属性是在 HTML5 中新增的。禁用了使用浏览器的默认验证。

- ng-app 指令定义了 AngularJS 应用。
- ng-controller 指令定义了应用控制器。
- ng-model 指令绑定了两个 input 元素到模型的 user 对象。
- formCtrl 函数设置了 master 对象的初始值，并定义了 reset() 方法。
- reset() 方法设置了 user 对象等于 master 对象。
- ng-click 指令调用了 reset() 方法，且在点击按钮时调用。
- novalidate 属性在应用中不是必须的，但是你需要在 AngularJS表单中使用，用于重写标准的 HTML5 验证

**AngularJS API**

| API                 | 描述                                          |
| ------------------- | --------------------------------------------- |
| angular.lowercase() | 转换字符串为小写                              |
| angular.uppercase() | 转换字符串为大写                              |
| angular.isString()  | 判断给定的对象是否为字符串，如果是返回 true。 |
| angular.isNumber()  | 判断给定的对象是否为数字，如果是返回 true。   |

```html 
<div ng-app="myApp" ng-controller="myCtrl">
<p>{{ x1 }}</p>
<p>{{ x2 }}</p>
</div>

<script>
var app = angular.module('myApp', []);
app.controller('myCtrl', function($scope) {
$scope.x1 = "JOHN";
$scope.x2 = angular.lowercase($scope.x1);
});
</script>
```

**AngularJS Bootstrap**

| AngularJS 指令       | 描述                                                   |
| -------------------- | ------------------------------------------------------ |
| < html ng-app        | 为 < html> 元素定义一个应用(未命名)                    |
| < body ng-controller | 为 < body> 元素定义一个控制器                          |
| < tr ng-repeat       | 循环 users 对象数组，每个 user 对象放在 < tr> 元素中。 |
| < button ng-click    | 当点击 < button> 元素时调用函数 editUser()             |
| < h3 ng-show         | 如果 edit = true 显示 < h3> 元素                       |
| < h3 ng-hide         | 如果 edit = true 隐藏 < h3> 元素                       |
| < input ng-model     | 为应用程序绑定 < input> 元素                           |
| < button ng-disabled | 如果发生错误或者 ncomplete = true 禁用 < button> 元素  |

**AngularJS 包含**

在 AngularJS 中，你可以在 HTML 中包含 HTML 文件。

使用 AngularJS, 你可以使用 ng-include 指令来包含 HTML 内容:

```html
<body>

<div class="container">
  <div ng-include="'myUsers_List.htm'"></div>
  <div ng-include="'myUsers_Form.htm'"></div>
</div>

</body>
```

**AngularJS 动画**

AngularJS 提供了动画效果，可以配合 CSS 使用。
AngularJS 使用动画需要引入 angular-animate.min.js 库。

```html
<body ng-app="myApp">

<h1>隐藏 DIV: <input type="checkbox" ng-model="myCheck"></h1>

<div ng-hide="myCheck"></div>

<script>
var app = angular.module('myApp', ['ngAnimate']);
</script>
```

ngAnimate 模型可以添加或移除 class 。
ngAnimate 模型并不能使 HTML 元素产生动画，但是 ngAnimate 会监测事件，类似隐藏显示 HTML 元素 ，如果事件发生 ngAnimate 就会使用预定义的 class 来设置 HTML 元素的动画。

AngularJS 添加/移除 class 的指令:

- ng-show
- ng-hide
- ng-class
- ng-view
- ng-include
- ng-repeat
- ng-if
- ng-switch

此外，在动画完成后，HTML 元素的类集合将被移除。例如： ng-hide 指令会添加一下类：

- ng-animate
- ng-hide-animate
- ng-hide-add (如果元素将被隐藏)
- ng-hide-remove (如果元素将显示)
- ng-hide-add-active (如果元素将隐藏)
- ng-hide-remove-active (如果元素将显示)

[TOC]

# 2016年3月30日

## 转义字符

字符型常量所表示的值是字符型变量所能包含的值。
我们可以用**ASCII表达式**来表示一个字符型常量，或者用**单引号**内加**反斜杠**表示转义字符。

> 其中：\x表示后面的字符是十六进制数，\表示后面的字符是八进制数。

`&#x50;`(&#x50;):用十六进制的方式表示编码为**50**的字符。
`&#50;`(&#50;):用十进制的方式表示编码为**50**的字符。
`\045`:在javascript中可解释成八进制的ASCII 码\"**%**\"。
`\x24`:在javascript中可以解释成十六进制的ASCII码\"**$**\"

在CSS中表示ASCII码：

```css
#t1:after{
        content: "\45\0a\55\045"
    }
```

